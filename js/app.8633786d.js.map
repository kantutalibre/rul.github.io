{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/assets/sounds/tick.mp3","webpack:///./node_modules/moment/locale sync ^\\.\\/.*$","webpack:///./src/App.vue?d034","webpack:///./src/components/Wheel.vue?6ca1","webpack:///src/components/Wheel.vue","webpack:///./src/components/Wheel.vue?8281","webpack:///./src/components/Wheel.vue","webpack:///src/App.vue","webpack:///./src/App.vue?a7d1","webpack:///./src/App.vue","webpack:///./src/plugins/ant-design-vue.js","webpack:///./src/lib/util.js","webpack:///./src/main.js","webpack:///./src/App.vue?f446","webpack:///./src/components/Winwheel.js","webpack:///./src/components/Wheel.vue?b5e4"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","map","webpackContext","req","id","webpackContextResolve","e","Error","code","keys","resolve","_vm","this","_h","$createElement","_c","_self","attrs","scopedSlots","_u","fn","props","item","title","text","type","on","splitOptions","model","callback","$$v","options","expression","loadOptions","_v","formattedOoptions","staticRenderFns","staticClass","staticStyle","_s","prizeName","$event","preventDefault","startSpin","number","segments","methods","computed","updated","mounted","created","component","components","Wheel","lstOptions","colours","showList","Vue","use","Antd","install","notification","success","texto","$notify","group","error","warning","info","$notification","config","productionTip","Notifications","util","render","h","App","$mount","Winwheel","drawWheel","defaultOptions","canvasId","centerX","centerY","outerRadius","innerRadius","numSegments","drawMode","rotationAngle","textFontFamily","textFontSize","textFontWeight","textOrientation","textAlignment","textDirection","textMargin","textFillStyle","textStrokeStyle","textLineWidth","fillStyle","strokeStyle","lineWidth","clearTheCanvas","imageOverlay","drawText","pointerAngle","wheelImage","imageDirection","canvas","document","getElementById","width","height","ctx","getContext","cavnas","Array","x","Segment","updateSegmentSizes","animation","Animation","pins","Pin","pointerGuide","PointerGuide","draw","winwheelToDrawDuringAnimation","winhweelAlreadyDrawn","y","image","imgData","Image","onload","winwheelLoadedImage","src","arcUsed","numSet","size","arcLeft","degreesEach","currentDegree","startAngle","endAngle","clearRect","clearCanvas","drawWheelImage","drawSegmentText","drawSegments","drawSegmentImages","visible","drawPins","display","drawPointerGuide","pinSpacing","save","translate","rotate","degToRad","beginPath","arc","margin","Math","PI","fill","stroke","restore","moveTo","lineTo","imageLeft","imageTop","drawImage","seg","imageAngle","console","log","fontFamily","fontSize","fontWeight","orientation","alignment","direction","fontSetting","font","lines","split","lineOffset","textAlign","textBaseline","textAngle","fillText","strokeText","yPos","yInc","character","charAt","centerAdjustment","radius","anglePerChar","drawAngle","radiusPercent","totalArc","position","segmentPos","newSegment","undefined","bbox","getBoundingClientRect","floor","left","top","foundSegment","segmentNumber","getSegmentNumberAt","topBottom","leftRight","adjacentSideLength","oppositeSideLength","hypotenuseSideLength","loc","windowToCanvas","tanVal","atan","locationAngle","sqrt","round","rotatedPosition","getRotationPosition","abs","foundSegmentNumber","prizeNumber","getIndicatedSegmentNumber","indicatedPrize","rawAngle","relativeAngle","currentPin","totalPinAngle","timesPast360","ceil","computeAnimation","properties","propertyName","propertyValue","yoyo","repeat","easing","winwheelAnimationLoop","winwheelStopAnimation","tween","TweenMax","to","duration","canCallback","kill","pause","play","spins","stopAngle","_stopAngle","random","range","callbackFinished","callbackBefore","callbackAfter","callbackSound","soundTrigger","winwheelPercentToDegrees","percentValue","degrees","divider","eval","winwheelTriggerSound","_lastSoundTriggerNumber","currentTriggerNumber","getCurrentPinNumber","getIndicatedSegment","winwheelImageLoadCount"],"mappings":"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","file":"js/app.8633786d.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","module.exports = \"data:audio/mpeg;base64,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\"","var map = {\n\t\"./af\": \"2bfb\",\n\t\"./af.js\": \"2bfb\",\n\t\"./ar\": \"8e73\",\n\t\"./ar-dz\": \"a356\",\n\t\"./ar-dz.js\": \"a356\",\n\t\"./ar-kw\": \"423e\",\n\t\"./ar-kw.js\": \"423e\",\n\t\"./ar-ly\": \"1cfd\",\n\t\"./ar-ly.js\": \"1cfd\",\n\t\"./ar-ma\": \"0a84\",\n\t\"./ar-ma.js\": \"0a84\",\n\t\"./ar-sa\": \"8230\",\n\t\"./ar-sa.js\": \"8230\",\n\t\"./ar-tn\": \"6d83\",\n\t\"./ar-tn.js\": \"6d83\",\n\t\"./ar.js\": \"8e73\",\n\t\"./az\": \"485c\",\n\t\"./az.js\": \"485c\",\n\t\"./be\": \"1fc1\",\n\t\"./be.js\": \"1fc1\",\n\t\"./bg\": \"84aa\",\n\t\"./bg.js\": \"84aa\",\n\t\"./bm\": \"a7fa\",\n\t\"./bm.js\": \"a7fa\",\n\t\"./bn\": \"9043\",\n\t\"./bn-bd\": \"9686\",\n\t\"./bn-bd.js\": \"9686\",\n\t\"./bn.js\": \"9043\",\n\t\"./bo\": \"d26a\",\n\t\"./bo.js\": \"d26a\",\n\t\"./br\": \"6887\",\n\t\"./br.js\": \"6887\",\n\t\"./bs\": \"2554\",\n\t\"./bs.js\": \"2554\",\n\t\"./ca\": \"d716\",\n\t\"./ca.js\": \"d716\",\n\t\"./cs\": \"3c0d\",\n\t\"./cs.js\": \"3c0d\",\n\t\"./cv\": \"03ec\",\n\t\"./cv.js\": \"03ec\",\n\t\"./cy\": \"9797\",\n\t\"./cy.js\": \"9797\",\n\t\"./da\": \"0f14\",\n\t\"./da.js\": \"0f14\",\n\t\"./de\": \"b469\",\n\t\"./de-at\": \"b3eb\",\n\t\"./de-at.js\": \"b3eb\",\n\t\"./de-ch\": \"bb71\",\n\t\"./de-ch.js\": \"bb71\",\n\t\"./de.js\": \"b469\",\n\t\"./dv\": \"598a\",\n\t\"./dv.js\": \"598a\",\n\t\"./el\": \"8d47\",\n\t\"./el.js\": \"8d47\",\n\t\"./en-au\": \"0e6b\",\n\t\"./en-au.js\": \"0e6b\",\n\t\"./en-ca\": \"3886\",\n\t\"./en-ca.js\": \"3886\",\n\t\"./en-gb\": \"39a6\",\n\t\"./en-gb.js\": \"39a6\",\n\t\"./en-ie\": \"e1d3\",\n\t\"./en-ie.js\": \"e1d3\",\n\t\"./en-il\": \"7333\",\n\t\"./en-il.js\": \"7333\",\n\t\"./en-in\": \"ec2e\",\n\t\"./en-in.js\": \"ec2e\",\n\t\"./en-nz\": \"6f50\",\n\t\"./en-nz.js\": \"6f50\",\n\t\"./en-sg\": \"b7e9\",\n\t\"./en-sg.js\": \"b7e9\",\n\t\"./eo\": \"65db\",\n\t\"./eo.js\": \"65db\",\n\t\"./es\": \"898b\",\n\t\"./es-do\": \"0a3c\",\n\t\"./es-do.js\": \"0a3c\",\n\t\"./es-mx\": \"b5b7\",\n\t\"./es-mx.js\": \"b5b7\",\n\t\"./es-us\": \"55c9\",\n\t\"./es-us.js\": \"55c9\",\n\t\"./es.js\": \"898b\",\n\t\"./et\": \"ec18\",\n\t\"./et.js\": \"ec18\",\n\t\"./eu\": \"0ff2\",\n\t\"./eu.js\": \"0ff2\",\n\t\"./fa\": \"8df4\",\n\t\"./fa.js\": \"8df4\",\n\t\"./fi\": \"81e9\",\n\t\"./fi.js\": \"81e9\",\n\t\"./fil\": \"d69a\",\n\t\"./fil.js\": \"d69a\",\n\t\"./fo\": \"0721\",\n\t\"./fo.js\": \"0721\",\n\t\"./fr\": \"9f26\",\n\t\"./fr-ca\": \"d9f8\",\n\t\"./fr-ca.js\": \"d9f8\",\n\t\"./fr-ch\": \"0e49\",\n\t\"./fr-ch.js\": \"0e49\",\n\t\"./fr.js\": \"9f26\",\n\t\"./fy\": \"7118\",\n\t\"./fy.js\": \"7118\",\n\t\"./ga\": \"5120\",\n\t\"./ga.js\": \"5120\",\n\t\"./gd\": \"f6b4\",\n\t\"./gd.js\": \"f6b4\",\n\t\"./gl\": \"8840\",\n\t\"./gl.js\": \"8840\",\n\t\"./gom-deva\": \"aaf2\",\n\t\"./gom-deva.js\": \"aaf2\",\n\t\"./gom-latn\": \"0caa\",\n\t\"./gom-latn.js\": \"0caa\",\n\t\"./gu\": \"e0c5\",\n\t\"./gu.js\": \"e0c5\",\n\t\"./he\": \"c7aa\",\n\t\"./he.js\": \"c7aa\",\n\t\"./hi\": \"dc4d\",\n\t\"./hi.js\": \"dc4d\",\n\t\"./hr\": \"4ba9\",\n\t\"./hr.js\": \"4ba9\",\n\t\"./hu\": \"5b14\",\n\t\"./hu.js\": \"5b14\",\n\t\"./hy-am\": \"d6b6\",\n\t\"./hy-am.js\": \"d6b6\",\n\t\"./id\": \"5038\",\n\t\"./id.js\": \"5038\",\n\t\"./is\": \"0558\",\n\t\"./is.js\": \"0558\",\n\t\"./it\": \"6e98\",\n\t\"./it-ch\": \"6f12\",\n\t\"./it-ch.js\": \"6f12\",\n\t\"./it.js\": \"6e98\",\n\t\"./ja\": \"079e\",\n\t\"./ja.js\": \"079e\",\n\t\"./jv\": \"b540\",\n\t\"./jv.js\": \"b540\",\n\t\"./ka\": \"201b\",\n\t\"./ka.js\": \"201b\",\n\t\"./kk\": \"6d79\",\n\t\"./kk.js\": \"6d79\",\n\t\"./km\": \"e81d\",\n\t\"./km.js\": \"e81d\",\n\t\"./kn\": \"3e92\",\n\t\"./kn.js\": \"3e92\",\n\t\"./ko\": \"22f8\",\n\t\"./ko.js\": \"22f8\",\n\t\"./ku\": \"2421\",\n\t\"./ku.js\": \"2421\",\n\t\"./ky\": \"9609\",\n\t\"./ky.js\": \"9609\",\n\t\"./lb\": \"440c\",\n\t\"./lb.js\": \"440c\",\n\t\"./lo\": \"b29d\",\n\t\"./lo.js\": \"b29d\",\n\t\"./lt\": \"26f9\",\n\t\"./lt.js\": \"26f9\",\n\t\"./lv\": \"b97c\",\n\t\"./lv.js\": \"b97c\",\n\t\"./me\": \"293c\",\n\t\"./me.js\": \"293c\",\n\t\"./mi\": \"688b\",\n\t\"./mi.js\": \"688b\",\n\t\"./mk\": \"6909\",\n\t\"./mk.js\": \"6909\",\n\t\"./ml\": \"02fb\",\n\t\"./ml.js\": \"02fb\",\n\t\"./mn\": \"958b\",\n\t\"./mn.js\": \"958b\",\n\t\"./mr\": \"39bd\",\n\t\"./mr.js\": \"39bd\",\n\t\"./ms\": \"ebe4\",\n\t\"./ms-my\": \"6403\",\n\t\"./ms-my.js\": \"6403\",\n\t\"./ms.js\": \"ebe4\",\n\t\"./mt\": \"1b45\",\n\t\"./mt.js\": \"1b45\",\n\t\"./my\": \"8689\",\n\t\"./my.js\": \"8689\",\n\t\"./nb\": \"6ce3\",\n\t\"./nb.js\": \"6ce3\",\n\t\"./ne\": \"3a39\",\n\t\"./ne.js\": \"3a39\",\n\t\"./nl\": \"facd\",\n\t\"./nl-be\": \"db29\",\n\t\"./nl-be.js\": \"db29\",\n\t\"./nl.js\": \"facd\",\n\t\"./nn\": \"b84c\",\n\t\"./nn.js\": \"b84c\",\n\t\"./oc-lnc\": \"167b\",\n\t\"./oc-lnc.js\": \"167b\",\n\t\"./pa-in\": \"f3ff\",\n\t\"./pa-in.js\": \"f3ff\",\n\t\"./pl\": \"8d57\",\n\t\"./pl.js\": \"8d57\",\n\t\"./pt\": \"f260\",\n\t\"./pt-br\": \"d2d4\",\n\t\"./pt-br.js\": \"d2d4\",\n\t\"./pt.js\": \"f260\",\n\t\"./ro\": \"972c\",\n\t\"./ro.js\": \"972c\",\n\t\"./ru\": \"957c\",\n\t\"./ru.js\": \"957c\",\n\t\"./sd\": \"6784\",\n\t\"./sd.js\": \"6784\",\n\t\"./se\": \"ffff\",\n\t\"./se.js\": \"ffff\",\n\t\"./si\": \"eda5\",\n\t\"./si.js\": \"eda5\",\n\t\"./sk\": \"7be6\",\n\t\"./sk.js\": \"7be6\",\n\t\"./sl\": \"8155\",\n\t\"./sl.js\": \"8155\",\n\t\"./sq\": \"c8f3\",\n\t\"./sq.js\": \"c8f3\",\n\t\"./sr\": \"cf1e\",\n\t\"./sr-cyrl\": \"13e9\",\n\t\"./sr-cyrl.js\": \"13e9\",\n\t\"./sr.js\": \"cf1e\",\n\t\"./ss\": \"52bd\",\n\t\"./ss.js\": \"52bd\",\n\t\"./sv\": \"5fbd\",\n\t\"./sv.js\": \"5fbd\",\n\t\"./sw\": \"74dc\",\n\t\"./sw.js\": \"74dc\",\n\t\"./ta\": \"3de5\",\n\t\"./ta.js\": \"3de5\",\n\t\"./te\": \"5cbb\",\n\t\"./te.js\": \"5cbb\",\n\t\"./tet\": \"576c\",\n\t\"./tet.js\": \"576c\",\n\t\"./tg\": \"3b1b\",\n\t\"./tg.js\": \"3b1b\",\n\t\"./th\": \"10e8\",\n\t\"./th.js\": \"10e8\",\n\t\"./tk\": \"5aff\",\n\t\"./tk.js\": \"5aff\",\n\t\"./tl-ph\": \"0f38\",\n\t\"./tl-ph.js\": \"0f38\",\n\t\"./tlh\": \"cf75\",\n\t\"./tlh.js\": \"cf75\",\n\t\"./tr\": \"0e81\",\n\t\"./tr.js\": \"0e81\",\n\t\"./tzl\": \"cf51\",\n\t\"./tzl.js\": \"cf51\",\n\t\"./tzm\": \"c109\",\n\t\"./tzm-latn\": \"b53d\",\n\t\"./tzm-latn.js\": \"b53d\",\n\t\"./tzm.js\": \"c109\",\n\t\"./ug-cn\": \"6117\",\n\t\"./ug-cn.js\": \"6117\",\n\t\"./uk\": \"ada2\",\n\t\"./uk.js\": \"ada2\",\n\t\"./ur\": \"5294\",\n\t\"./ur.js\": \"5294\",\n\t\"./uz\": \"2e8c\",\n\t\"./uz-latn\": \"010e\",\n\t\"./uz-latn.js\": \"010e\",\n\t\"./uz.js\": \"2e8c\",\n\t\"./vi\": \"2921\",\n\t\"./vi.js\": \"2921\",\n\t\"./x-pseudo\": \"fd7e\",\n\t\"./x-pseudo.js\": \"fd7e\",\n\t\"./yo\": \"7f33\",\n\t\"./yo.js\": \"7f33\",\n\t\"./zh-cn\": \"5c3a\",\n\t\"./zh-cn.js\": \"5c3a\",\n\t\"./zh-hk\": \"49ab\",\n\t\"./zh-hk.js\": \"49ab\",\n\t\"./zh-mo\": \"3a6c\",\n\t\"./zh-mo.js\": \"3a6c\",\n\t\"./zh-tw\": \"90ea\",\n\t\"./zh-tw.js\": \"90ea\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"4678\";","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('notifications',{attrs:{\"group\":\"notification\",\"position\":\"bottom left\",\"duration\":6000,\"max\":2,\"width\":\"100%\"},scopedSlots:_vm._u([{key:\"body\",fn:function(props){return [_c('a-alert',{attrs:{\"message\":props.item.title,\"description\":props.item.text,\"type\":props.item.type,\"show-icon\":\"\"}})]}}])}),(_vm.showList)?_c('div',[_c('a-textarea',{attrs:{\"placeholder\":\"Ingrese opciones\",\"rows\":10},on:{\"change\":this.splitOptions},model:{value:(_vm.options),callback:function ($$v) {_vm.options=$$v},expression:\"options\"}}),_c('a-button',{attrs:{\"type\":\"primary\"},on:{\"click\":this.loadOptions}},[_vm._v(\" Cargar \")])],1):_c('diV',[_c('Wheel',{attrs:{\"segments\":_vm.formattedOoptions}})],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:\"vue-winwheel\"},[_c('div',{staticClass:\"mobile-container\"},[_c('br'),_c('h2',{staticStyle:{\"color\":\"white\"}},[_vm._v(\" \"+_vm._s(_vm.prizeName)+\" \")]),_c('br'),_c('br'),_c('div',{staticClass:\"wheel-wrapper\"},[_c('div',{staticClass:\"canvas-wrapper\"},[_c('canvas',{attrs:{\"id\":\"canvas\",\"width\":\"310\",\"height\":\"310\"},on:{\"click\":function($event){$event.preventDefault();return _vm.startSpin()}}},[_c('p',{staticStyle:{\"{color\":\"white}\"},attrs:{\"align\":\"center\"}},[_vm._v(\"Sorry, your browser doesn't support canvas. Please try Google Chrome.\")])])]),_c('div',{staticClass:\"button-wrapper\"})])])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n  <section class=\"vue-winwheel\">\r\n    <div class=\"mobile-container\">\r\n      <br/>\r\n      <h2 style=\"color:white; \">\r\n          {{prizeName}}\r\n        </h2>\r\n        <br/>\r\n        <br/>\r\n      <div class=\"wheel-wrapper\">\r\n        <div class=\"canvas-wrapper\">\r\n          <canvas id=\"canvas\" width=\"310\" height=\"310\" @click.prevent=\"startSpin()\">\r\n            <p style=\"{color: white}\" align=\"center\">Sorry, your browser doesn't support canvas. Please try Google Chrome.</p>\r\n          </canvas>\r\n        </div>     \r\n\r\n        <div class=\"button-wrapper\">\r\n          <!--\r\n          <a class=\"btn btn-play\" href=\"#\" @click.prevent=\"startSpin()\" v-if=\"!loadingPrize && !wheelSpinning\">SPIN!</a>\r\n        -->\r\n        </div>\r\n      \r\n      </div>\r\n     \r\n    </div>\r\n    <!--\r\n    <div class=\"custom-modal modal-mask\" id=\"modalSpinwheel\" v-if=\"modalPrize\">\r\n      <div slot=\"body\">\r\n        <a href=\"\" @click.prevent=\"hidePrize()\" class=\"modal-dismiss\">\r\n          <i class=\"icon_close\"></i>\r\n        </a>\r\n      \r\n      </div>\r\n    </div>\r\n-->\r\n  </section>\r\n</template>\r\n\r\n\r\n<script>\r\nimport * as Winwheel from './Winwheel'\r\n\r\n//const audio = new Audio('tick.mp3');  \r\nimport sound from '../assets/sounds/tick.mp3';\r\nconst audio = new Audio(sound);\r\n\r\nexport default {\r\nname: 'VueWinWheel',\r\nprops: ['segments'],\r\ndata () {\r\n  return {\r\n\r\n    \r\n\r\n    //loadingPrize: false,\r\n    theWheel: null,\r\n    modalPrize: false,\r\n    wheelPower: 1,\r\n    wheelSpinning: false,\r\n    prizeName: '.',\r\n    WinWheelOptions: {\r\n      textFontSize: 14,\r\n      outterRadius: 410,\r\n      innerRadius: 25,\r\n      lineWidth: 8,\r\n      animation: {\r\n        type: 'spinOngoing',\r\n        duration: 0.5\r\n      },\r\n      soundTrigger: 'pin',\r\n      pins:{\r\n          number: this.segments.length * 2\r\n      }\r\n    },\r\n\r\n    //audio: new Audio('tick.mp3') \r\n\r\n  }\r\n},\r\nmethods: {\r\n  showPrize () {\r\n   // console.log('Mostrar precio')\r\n    this.modalPrize = true\r\n  },\r\n  hidePrize () {\r\n    this.modalPrize = false\r\n  },\r\n  startSpin () {\r\n    this.prizeName='.'\r\n\r\n    if (this.wheelSpinning === false) {\r\n      this.theWheel.startAnimation()\r\n      this.wheelSpinning = true\r\n      this.theWheel = new Winwheel.Winwheel({\r\n        ...this.WinWheelOptions,\r\n        numSegments: this.segments.length,\r\n        segments: this.segments,\r\n        animation: {\r\n          type: 'spinToStop',\r\n          duration: 5,\r\n          spins: 5,\r\n          callbackFinished: this.onFinishSpin,\r\n\r\n          callbackSound: this.playSound,\r\n          //soundTrigger: 'pin' */     \r\n        }\r\n      })\r\n\r\n      // example input prize number get from Backend\r\n      // Important thing is to set the stopAngle of the animation before stating the spin.\r\n\r\n      var prizeNumber = Math.floor(Math.random() * this.segments.length) // or just get from Backend\r\n      //var stopAt = 360 / this.segments.length * prizeNumber - 360 / this.segments.length / 2 // center pin\r\n      var stopAt = 360 / this.segments.length * prizeNumber - Math.floor(Math.random() * 60) //random location\r\n      this.theWheel.animation.stopAngle = stopAt\r\n      this.theWheel.startAnimation()\r\n      this.wheelSpinning = false\r\n\r\n    }\r\n  },\r\n  resetWheel () {\r\n    this.theWheel = new Winwheel.Winwheel({\r\n      ...this.WinWheelOptions,\r\n      numSegments: this.segments.length,\r\n      segments: this.segments\r\n    })\r\n\r\n    if (this.wheelSpinning) {\r\n      this.theWheel.stopAnimation(false) // Stop the animation, false as param so does not call callback function.\r\n    }\r\n\r\n    this.theWheel.rotationAngle = 0 // Re-set the wheel angle to 0 degrees.\r\n    this.theWheel.draw() // Call draw to render changes to the wheel.\r\n    this.wheelSpinning = false // Reset to false to power buttons and spin can be clicked again.\r\n  },\r\n  initSpin () {\r\n    //his.loadingPrize = true\r\n          this.resetWheel()\r\n         // this.loadingPrize = false\r\n  },\r\n  onFinishSpin (indicatedSegment) {\r\n    this.prizeName = indicatedSegment.text\r\n    ///this.showPrize()\r\n  },\r\n  \r\n           playSound()\r\n            {\r\n                // Stop and rewind the sound if it already happens to be playing.\r\n                audio.pause();\r\n                audio.currentTime = 0;\r\n\r\n                // Play the sound.\r\n                //audio.play();\r\n                var promise = audio.play();\r\nif (promise) {\r\n    //Older browsers may not return a promise, according to the MDN website\r\n    promise.catch(function(error) { console.error(error.message); });\r\n}\r\n            }\r\n\r\n},\r\ncomputed: {},\r\nupdated () {},\r\nmounted () {\r\n  this.initSpin()\r\n //this.resetWheel()\r\n},\r\ncreated () {}\r\n}\r\n\r\n</script>\r\n\r\n<style scoped>\r\n\r\n.mobile-container {\r\n  background-image: url('../assets/images/banner.jpg');\r\nbackground-size: cover;\r\nbackground-position: center bottom;\r\nbackground-repeat: no-repeat;\r\n}\r\n.vue-winwheel {\r\ntext-align: center;\r\n/*background-image: url('../assets/images/banner.jpg');\r\nbackground-size: cover;\r\nbackground-position: center bottom;\r\nbackground-repeat: no-repeat;*/\r\n}\r\n.vue-winwheel h1 {\r\ncolor: #b32656;\r\nfont-family: 'Avenir', Helvetica, Arial, sans-serif;\r\nfont-size: 36px;\r\nline-height: 90px;\r\nletter-spacing: 4px;\r\nmargin: 0;\r\n}\r\n.vue-winwheel h2 {\r\nmargin: 0;\r\n}\r\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content {\r\nwidth: calc(100vw - 30px);\r\npadding-top: 52px;\r\n}\r\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content h2 {\r\ntext-transform: uppercase;\r\ncolor: #b32656;\r\nmargin-bottom: 16px;\r\nmargin-top: 0;\r\nfont-family: 'Avenir', Helvetica, Arial, sans-serif;\r\nfont-size: 18px;\r\nletter-spacing: 1.1px;\r\nmargin: 0;\r\n}\r\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content p {\r\nfont-family: 'Avenir', Helvetica, Arial, sans-serif;\r\nfont-size: 14px;\r\ncolor: black;\r\ntext-align: center;\r\nline-height: 25px;\r\n}\r\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content p strong {\r\nfont-family: 'Avenir', Helvetica, Arial, sans-serif;\r\n}\r\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content .modal-dismiss {\r\ntop: 12px;\r\nright: 12px;\r\n}\r\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content .modal-dismiss i.icon_close {\r\nfont-size: 30px;\r\ncolor: #da2a52;\r\n}\r\n.vue-winwheel canvas#canvas {\r\nposition: relative;\r\n}\r\n.vue-winwheel .canvas-wrapper {\r\nposition: relative;\r\n}\r\n.vue-winwheel .canvas-wrapper:after {\r\ncontent: '';\r\ndisplay: block;\r\nwidth: 42px;\r\nbackground: #c4376f;\r\nheight: 42px;\r\nposition: absolute;\r\nleft: calc(50% - 25px);\r\nmargin: auto;\r\nborder-radius: 100%;\r\ntop: calc(50% - 29px);\r\nborder: 5px solid white;\r\nbox-sizing: content-box;\r\n}\r\n.vue-winwheel .canvas-wrapper:before {\r\ncontent: '';\r\ndisplay: block;\r\nwidth: 310px;\r\nbackground: white/*#0f0f0f*/;\r\nheight: 310px;\r\nposition: absolute;\r\nleft: 0;\r\nright: 0;\r\nmargin: 0 auto;\r\nborder-radius: 100%;\r\ntop: 0;\r\n}\r\n.vue-winwheel .wheel-wrapper {\r\nposition: relative;\r\n}\r\n.vue-winwheel .wheel-wrapper:before {\r\ncontent: '';\r\nwidth: 62px;\r\nheight: 47px;\r\nposition: absolute;\r\ntop: -10px;\r\nleft: calc(50% - 31px);\r\nright: 0;\r\ndisplay: block;\r\nz-index: 99999;\r\nbackground-image: url('../assets/images/spinner-marker.svg');\r\nbackground-repeat: no-repeat;\r\nbackground-size: contain;\r\nbackground-position: center;\r\n}\r\n.vue-winwheel .wheel-wrapper .button-wrapper {\r\nmargin: 0 auto;\r\ndisplay: flex;\r\nflex-direction: column;\r\nalign-items: center;\r\njustify-content: center;\r\nwidth: 231px;\r\nheight: 118px;\r\n}\r\n.vue-winwheel .wheel-wrapper .btn.btn-play {\r\npadding: 0 58px !important;\r\nbackground: #c4376f;\r\nheight: 40px;\r\nline-height: 40px;\r\ncolor: white;\r\nfont-weight: bold;\r\ntext-decoration: none;\r\nborder-radius: 2px;\r\nfont-family: 'Avenir', Helvetica, Arial, sans-serif;\r\nletter-spacing: 2px;\r\n}\r\n</style>\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Wheel.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Wheel.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Wheel.vue?vue&type=template&id=1cb22e24&scoped=true&\"\nimport script from \"./Wheel.vue?vue&type=script&lang=js&\"\nexport * from \"./Wheel.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Wheel.vue?vue&type=style&index=0&id=1cb22e24&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1cb22e24\",\n  null\n  \n)\n\nexport default component.exports","<template>\n  <div id=\"app\">\n    <notifications\n      group=\"notification\"\n      position=\"bottom left\"\n      :duration=\"6000\"\n      :max=\"2\"\n      width=\"100%\"\n    >\n      <template slot=\"body\" slot-scope=\"props\">\n        <a-alert\n          :message=\"props.item.title\"\n          :description=\"props.item.text\"\n          :type=\"props.item.type\"\n          show-icon\n        />\n      </template>\n    </notifications>\n    <div v-if=\"showList\">\n      <a-textarea \n        v-model=\"options\" \n        placeholder=\"Ingrese opciones\" \n        :rows=\"10\" \n        @change=\"this.splitOptions\"\n        \n      />\n      <a-button type=\"primary\"\n        @click=\"this.loadOptions\"\n      >\n      Cargar\n    </a-button>\n  </div>\n  <diV v-else>\n    <Wheel :segments=\"formattedOoptions\"/>\n  </diV>\n\n  \n  </div>\n</template>\n\n<script>\n\nimport Wheel from './components/Wheel.vue'\n\nexport default {\n  components: {\n    Wheel\n  },\n  \n  data() {\n    return {\n      formattedOoptions:[],\n      options: '',\n      lstOptions: [],\n      colours: ['rgb(253,162,135)','rgb(235,109,121)','rgb(112,66,105','rgb(115,101,162)','rgb(96,81,102)','rgb(51,69,101)',\n      'rgb(253,162,135)','rgb(235,109,121)','rgb(112,66,105','rgb(115,101,162)','rgb(96,81,102)','rgb(51,69,101)',\n      'rgb(253,162,135)','rgb(235,109,121)','rgb(112,66,105','rgb(115,101,162)','rgb(96,81,102)','rgb(51,69,101)',\n      'rgb(253,162,135)','rgb(235,109,121)','rgb(112,66,105','rgb(115,101,162)','rgb(96,81,102)','rgb(51,69,101)',\n      'rgb(253,162,135)','rgb(235,109,121)','rgb(112,66,105','rgb(115,101,162)','rgb(96,81,102)','rgb(51,69,101)'],\n\n      showList:true\n    }\n  },\n  methods: {\n    splitOptions() {\n    this.lstOptions = this.options.split(/\\r?\\n/)\n   },\n   toConvert(lstOptions) {\n    let option; \n    lstOptions.map((item,index) => {\n      option = new Object();\n      option.textFillStyle = 'white'\n      option.fillStyle = this.colours[index]\n      option.text = item\n\n      this.formattedOoptions.push(option)\n      console.log(this.formattedOoptions)\n    })\n  \n   \n   },\n   loadOptions() {\n    this.toConvert(this.lstOptions)\n    this.showList = false\n   }\n  }\n\n};\n</script>\n\n\n<style lang=\"scss\">\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n}\n\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=4fe9bd91&\"\nimport script from \"./App.vue?vue&type=script&lang=js&\"\nexport * from \"./App.vue?vue&type=script&lang=js&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import Vue from 'vue';\r\nimport Antd from 'ant-design-vue';\r\nimport 'ant-design-vue/dist/antd.css';\r\n\r\n\r\nVue.use(Antd);\r\n","export default {\r\n  install(Vue) {\r\n    \r\n    /**Notificaciones */\r\n    const notification = {\r\n      success(texto) {\r\n        Vue.prototype.$notify({\r\n          group: 'notification',\r\n          title: 'Éxito',\r\n          text: texto,\r\n          type: 'success'\r\n        });\r\n      },\r\n      error(texto) {\r\n        Vue.prototype.$notify({\r\n          group: \"notification\",\r\n          title: 'Error',\r\n          text: texto,\r\n          type: \"error\"\r\n        });\r\n      },\r\n      warning(texto) {\r\n        Vue.prototype.$notify({\r\n          group: \"notification\",\r\n          title: \"Advertencia\",\r\n          text: texto,\r\n          type: \"warning\"\r\n        });\r\n      },\r\n      info(texto) {\r\n        Vue.prototype.$notify({\r\n          group: \"notification\",\r\n          title: \"Información\",\r\n          text: texto,\r\n          type: \"info\"\r\n        });\r\n      },\r\n    };\r\n    Vue.prototype.$notification = notification;\r\n\r\n  }\r\n}","import Vue from 'vue'\r\nimport App from './App.vue'\r\nimport './plugins/ant-design-vue.js';\r\nimport Notifications from 'vue-notification'\r\n\r\nVue.config.productionTip = false\r\n\r\nVue.use(Notifications)\r\nimport util from './lib/util';\r\nVue.use(util);\r\n\r\nnew Vue({\r\n  render: h => h(App)\r\n}).$mount('#app')\r\n","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"","\r\n/* eslint-disable */\r\nimport { TweenMax } from 'gsap'\r\n\r\nexport class Winwheel {\r\n\tconstructor(options, drawWheel) {\r\n\t\tvar defaultOptions = {\r\n\t\t\tcanvasId: 'canvas', // Id of the canvas which the wheel is to draw on to.\r\n\t\t\tcenterX: null, // X position of the center of the wheel. The default of these are null which means will be placed in center of the canvas.\r\n\t\t\tcenterY: null, // Y position of the wheel center. If left null at time of construct the center of the canvas is used.\r\n\t\t\touterRadius: null, // The radius of the outside of the wheel. If left null it will be set to the radius from the center of the canvas to its shortest side.\r\n\t\t\tinnerRadius: 0, // Normally 0. Allows the creation of rings / doughnuts if set to value > 0. Should not exceed outer radius.\r\n\t\t\tnumSegments: 1, // The number of segments. Need at least one to draw.\r\n\t\t\tdrawMode: 'code', // The draw mode. Possible values are 'code', 'image', 'segmentImage'. Default is code which means segments are drawn using canvas arc() function.\r\n\t\t\trotationAngle: 0, // The angle of rotation of the wheel - 0 is 12 o'clock position.\r\n\t\t\ttextFontFamily: 'sans-serif', // Segment text font, you should use web safe fonts.\r\n\t\t\ttextFontSize: 13, // Size of the segment text.\r\n\t\t\ttextFontWeight: 'bold', // Font weight.\r\n\t\t\ttextOrientation: 'horizontal', // Either horizontal, vertical, or curved.\r\n\t\t\ttextAlignment: 'center', // Either center, inner, or outer.\r\n\t\t\ttextDirection: 'normal', // Either normal or reversed. In normal mode for horizontal text in segment at 3 o'clock is correct way up, in reversed text at 9 o'clock segment is correct way up.\r\n\t\t\ttextMargin: null, // Margin between the inner or outer of the wheel (depends on textAlignment).\r\n\t\t\ttextFillStyle: 'black', // This is basically the text colour.\r\n\t\t\ttextStrokeStyle: null, // Basically the line colour for segment text, only looks good for large text so off by default.\r\n\t\t\ttextLineWidth: 1, // Width of the lines around the text. Even though this defaults to 1, a line is only drawn if textStrokeStyle specified.\r\n\t\t\tfillStyle: 'silver', // The segment background colour.\r\n\t\t\tstrokeStyle: null, // Segment line colour. Again segment lines only drawn if this is specified.\r\n\t\t\tlineWidth: 1, // Width of lines around segments.\r\n\t\t\tclearTheCanvas: true, // When set to true the canvas will be cleared before the wheel is drawn.\r\n\t\t\timageOverlay: false, // If set to true in image drawing mode the outline of the segments will be displayed over the image. Does nothing in code drawMode.\r\n\t\t\tdrawText: true, // By default the text of the segments is rendered in code drawMode and not in image drawMode.\r\n\t\t\tpointerAngle: 0, // Location of the pointer that indicates the prize when wheel has stopped. Default is 0 so the (corrected) 12 o'clock position.\r\n\t\t\twheelImage: null, // Must be set to image data in order to use image to draw the wheel - drawMode must also be 'image'.\r\n\t\t\timageDirection: 'N', // Used when drawMode is segmentImage. Default is north, can also be (E)ast, (S)outh, (W)est.\r\n\t\t}\r\n\r\n\t\t// -----------------------------------------\r\n\t\t// Loop through the default options and create properties of this class set to the value for the option passed in\r\n\t\t// or if not value for the option was passed in then to the default.\r\n\t\tfor (var key in defaultOptions) {\r\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\r\n\t\t\t\tthis[key] = options[key]\r\n\t\t\t} else {\r\n\t\t\t\tthis[key] = defaultOptions[key]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\r\n\t\tif (options != null) {\r\n\t\t\tfor (var key in options) {\r\n\t\t\t\tif (typeof this[key] === 'undefined') {\r\n\t\t\t\t\tthis[key] = options[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// If the id of the canvas is set, try to get the canvas as we need it for drawing.\r\n\t\tif (this.canvasId) {\r\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\r\n\r\n\t\t\tif (this.canvas) {\r\n\t\t\t\t// If the centerX and centerY have not been specified in the options then default to center of the canvas\r\n\t\t\t\t// and make the outerRadius half of the canvas width - this means the wheel will fill the canvas.\r\n\t\t\t\tif (this.centerX == null) {\r\n\t\t\t\t\tthis.centerX = this.canvas.width / 2\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.centerY == null) {\r\n\t\t\t\t\tthis.centerY = this.canvas.height / 2\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.outerRadius == null) {\r\n\t\t\t\t\t// Need to set to half the width of the shortest dimension of the canvas as the canvas may not be square.\r\n\t\t\t\t\t// Minus the line segment line width otherwise the lines around the segments on the top,left,bottom,right\r\n\t\t\t\t\t// side are chopped by the edge of the canvas.\r\n\t\t\t\t\tif (this.canvas.width < this.canvas.height) {\r\n\t\t\t\t\t\tthis.outerRadius = this.canvas.width / 2 - this.lineWidth\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.outerRadius = this.canvas.height / 2 - this.lineWidth\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Also get a 2D context to the canvas as we need this to draw with.\r\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\r\n\t\t\t} else {\r\n\t\t\t\tthis.canvas = null\r\n\t\t\t\tthis.ctx = null\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.cavnas = null\r\n\t\t\tthis.ctx = null\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// Add array of segments to the wheel, then populate with segments if number of segments is specified for this object.\r\n\t\tthis.segments = new Array(null)\r\n\r\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\r\n\t\t\t// If options for the segments have been specified then create a segment sending these options so\r\n\t\t\t// the specified values are used instead of the defaults.\r\n\t\t\tif (options != null && options['segments'] && typeof options['segments'][x - 1] !== 'undefined') {\r\n\t\t\t\tthis.segments[x] = new Segment(options['segments'][x - 1])\r\n\t\t\t} else {\r\n\t\t\t\tthis.segments[x] = new Segment()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// Call function to update the segment sizes setting the starting and ending angles.\r\n\t\tthis.updateSegmentSizes()\r\n\r\n\t\t// If the text margin is null then set to same as font size as we want some by default.\r\n\t\tif (this.textMargin === null) {\r\n\t\t\tthis.textMargin = this.textFontSize / 1.7\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// If the animation options have been passed in then create animation object as a property of this class\r\n\t\t// and pass the options to it so the animation is set. Otherwise create default animation object.\r\n\t\tif (options != null && options['animation'] && typeof options['animation'] !== 'undefined') {\r\n\t\t\tthis.animation = new Animation(options['animation'])\r\n\t\t} else {\r\n\t\t\tthis.animation = new Animation()\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// If some pin options then create create a pin object and then pass them in.\r\n\t\tif (options != null && options['pins'] && typeof options['pins'] !== 'undefined') {\r\n\t\t\tthis.pins = new Pin(options['pins'])\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// On that note, if the drawMode is image change some defaults provided a value has not been specified.\r\n\t\tif (this.drawMode == 'image' || this.drawMode == 'segmentImage') {\r\n\t\t\t// Remove grey fillStyle.\r\n\t\t\tif (typeof options['fillStyle'] === 'undefined') {\r\n\t\t\t\tthis.fillStyle = null\r\n\t\t\t}\r\n\r\n\t\t\t// Set strokeStyle to red.\r\n\t\t\tif (typeof options['strokeStyle'] === 'undefined') {\r\n\t\t\t\tthis.strokeStyle = 'red'\r\n\t\t\t}\r\n\r\n\t\t\t// Set drawText to false as we will assume any text is part of the image.\r\n\t\t\tif (typeof options['drawText'] === 'undefined') {\r\n\t\t\t\tthis.drawText = false\r\n\t\t\t}\r\n\r\n\t\t\t// Also set the lineWidth to 1 so that segment overlay will look correct.\r\n\t\t\tif (typeof options['lineWidth'] === 'undefined') {\r\n\t\t\t\tthis.lineWidth = 1\r\n\t\t\t}\r\n\r\n\t\t\t// Set drawWheel to false as normally the image needs to be loaded first.\r\n\t\t\tif (typeof drawWheel === 'undefined') {\r\n\t\t\t\tdrawWheel = false\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// When in code drawMode the default is the wheel will draw.\r\n\t\t\tif (typeof drawWheel === 'undefined') {\r\n\t\t\t\tdrawWheel = true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Create pointer guide.\r\n\t\tif (options != null && options['pointerGuide'] && typeof options['pointerGuide'] !== 'undefined') {\r\n\t\t\tthis.pointerGuide = new PointerGuide(options['pointerGuide'])\r\n\t\t} else {\r\n\t\t\tthis.pointerGuide = new PointerGuide()\r\n\t\t}\r\n\r\n\t\t// Finally if drawWheel is true then call function to render the wheel, segment text, overlay etc.\r\n\t\tif (drawWheel == true) {\r\n\t\t\tthis.draw(this.clearTheCanvas)\r\n\t\t} else if (this.drawMode == 'segmentImage') {\r\n\t\t\t// If segment image then loop though all the segments and load the images for them setting a callback\r\n\t\t\t// which will call the draw function of the wheel once all the images have been loaded.\r\n\t\t\twinwheelToDrawDuringAnimation = this\r\n\t\t\twinhweelAlreadyDrawn = false\r\n\r\n\t\t\tfor (var y = 1; y <= this.numSegments; y++) {\r\n\t\t\t\tif (this.segments[y].image !== null) {\r\n\t\t\t\t\tthis.segments[y].imgData = new Image()\r\n\t\t\t\t\tthis.segments[y].imgData.onload = winwheelLoadedImage\r\n\t\t\t\t\tthis.segments[y].imgData.src = this.segments[y].image\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function sorts out the segment sizes. Some segments may have set sizes, for the others what is left out of\r\n\t// 360 degrees is shared evenly. What this function actually does is set the start and end angle of the arcs.\r\n\t// ====================================================================================================================\r\n\tupdateSegmentSizes() {\r\n\t\t// If this object actually contains some segments\r\n\t\tif (this.segments) {\r\n\t\t\t// First add up the arc used for the segments where the size has been set.\r\n\t\t\tvar arcUsed = 0\r\n\t\t\tvar numSet = 0\r\n\r\n\t\t\t// Remember, to make it easy to access segments, the position of the segments in the array starts from 1 (not 0).\r\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\r\n\t\t\t\tif (this.segments[x].size !== null) {\r\n\t\t\t\t\tarcUsed += this.segments[x].size\r\n\t\t\t\t\tnumSet++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar arcLeft = 360 - arcUsed\r\n\r\n\t\t\t// Create variable to hold how much each segment with non-set size will get in terms of degrees.\r\n\t\t\tvar degreesEach = 0\r\n\r\n\t\t\tif (arcLeft > 0) {\r\n\t\t\t\tdegreesEach = arcLeft / (this.numSegments - numSet)\r\n\t\t\t}\r\n\r\n\t\t\t// ------------------------------------------\r\n\t\t\t// Now loop though and set the start and end angle of each segment.\r\n\t\t\tvar currentDegree = 0\r\n\r\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\r\n\t\t\t\t// Set start angle.\r\n\t\t\t\tthis.segments[x].startAngle = currentDegree\r\n\r\n\t\t\t\t// If the size is set then add this to the current degree to get the end, else add the degreesEach to it.\r\n\t\t\t\tif (this.segments[x].size) {\r\n\t\t\t\t\tcurrentDegree += this.segments[x].size\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentDegree += degreesEach\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set end angle.\r\n\t\t\t\tthis.segments[x].endAngle = currentDegree\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function clears the canvas. Will wipe anything else which happens to be drawn on it.\r\n\t// ====================================================================================================================\r\n\tclearCanvas() {\r\n\t\tif (this.ctx) {\r\n\t\t\tthis.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function draws / re-draws the wheel on the canvas therefore rendering any changes.\r\n\t// ====================================================================================================================\r\n\tdraw(clearTheCanvas) {\r\n\t\t// If have the canvas context.\r\n\t\tif (this.ctx) {\r\n\t\t\t// Clear the canvas, unless told not to.\r\n\t\t\tif (typeof clearTheCanvas !== 'undefined') {\r\n\t\t\t\tif (clearTheCanvas == true) {\r\n\t\t\t\t\tthis.clearCanvas()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.clearCanvas()\r\n\t\t\t}\r\n\r\n\t\t\t// Call functions to draw the segments and then segment text.\r\n\t\t\tif (this.drawMode == 'image') {\r\n\t\t\t\t// Draw the wheel by loading and drawing an image such as a png on the canvas.\r\n\t\t\t\tthis.drawWheelImage()\r\n\r\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\r\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\r\n\t\t\t\tif (this.drawText == true) {\r\n\t\t\t\t\tthis.drawSegmentText()\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\r\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\r\n\t\t\t\tif (this.imageOverlay == true) {\r\n\t\t\t\t\tthis.drawSegments()\r\n\t\t\t\t}\r\n\t\t\t} else if (this.drawMode == 'segmentImage') {\r\n\t\t\t\t// Draw the wheel by rendering the image for each segment.\r\n\t\t\t\tthis.drawSegmentImages()\r\n\r\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\r\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\r\n\t\t\t\tif (this.drawText == true) {\r\n\t\t\t\t\tthis.drawSegmentText()\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\r\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\r\n\t\t\t\tif (this.imageOverlay == true) {\r\n\t\t\t\t\tthis.drawSegments()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// The default operation is to draw the segments using code via the canvas arc() method.\r\n\t\t\t\tthis.drawSegments()\r\n\r\n\t\t\t\t// The text is drawn on top.\r\n\t\t\t\tif (this.drawText == true) {\r\n\t\t\t\t\tthis.drawSegmentText()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If this class has pins.\r\n\t\t\tif (typeof this.pins !== 'undefined') {\r\n\t\t\t\t// If they are to be visible then draw them.\r\n\t\t\t\tif (this.pins.visible == true) this.drawPins()\r\n\t\t\t}\r\n\r\n\t\t\t// If pointer guide is display property is set to true then call function to draw the pointer guide.\r\n\t\t\tif (this.pointerGuide.display == true) {\r\n\t\t\t\tthis.drawPointerGuide()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Draws the pins around the outside of the wheel.\r\n\t// ====================================================================================================================\r\n\tdrawPins() {\r\n\t\tif (this.pins && this.pins.number) {\r\n\t\t\t// Work out the angle to draw each pin a which is simply 360 / the number of pins as they space evenly around.\r\n\t\t\t//++ There is a slight oddity with the pins in that there is a pin at 0 and also one at 360 and these will be drawn\r\n\t\t\t//++ directly over the top of each other. Also pins are 0 indexed which could possibly cause some confusion\r\n\t\t\t//++ with the getCurrentPin function - for now this is just used for audio so probably not a problem.\r\n\t\t\tvar pinSpacing = 360 / this.pins.number\r\n\r\n\t\t\tfor (var i = 1; i <= this.pins.number; i++) {\r\n\t\t\t\tthis.ctx.save()\r\n\r\n\t\t\t\t// Set the stroke style and line width.\r\n\t\t\t\tthis.ctx.strokeStyle = this.pins.strokeStyle\r\n\t\t\t\tthis.ctx.lineWidth = this.pins.lineWidth\r\n\t\t\t\tthis.ctx.fillStyle = this.pins.fillStyle\r\n\r\n\t\t\t\t// Move to the center.\r\n\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\r\n\t\t\t\t// Rotate to to the pin location which is i * the pinSpacing.\r\n\t\t\t\tthis.ctx.rotate(this.degToRad(i * pinSpacing + this.rotationAngle))\r\n\r\n\t\t\t\t// Move back out.\r\n\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t// Create a path for the pin circle.\r\n\t\t\t\tthis.ctx.beginPath()\r\n\t\t\t\t// x, y, radius, startAngle, endAngle.\r\n\t\t\t\tthis.ctx.arc(\r\n\t\t\t\t\tthis.centerX,\r\n\t\t\t\t\tthis.centerY - this.outerRadius + this.pins.outerRadius + this.pins.margin,\r\n\t\t\t\t\tthis.pins.outerRadius,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t2 * Math.PI\r\n\t\t\t\t)\r\n\r\n\t\t\t\tif (this.pins.fillStyle) this.ctx.fill()\r\n\r\n\t\t\t\tif (this.pins.strokeStyle) this.ctx.stroke()\r\n\r\n\t\t\t\tthis.ctx.restore()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Draws a line from the center of the wheel to the outside at the angle where the code thinks the pointer is.\r\n\t// ====================================================================================================================\r\n\tdrawPointerGuide() {\r\n\t\t// If have canvas context.\r\n\t\tif (this.ctx) {\r\n\t\t\tthis.ctx.save()\r\n\r\n\t\t\t// Rotate the canvas to the line goes towards the location of the pointer.\r\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\tthis.ctx.rotate(this.degToRad(this.pointerAngle))\r\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t// Set line colour and width.\r\n\t\t\tthis.ctx.strokeStyle = this.pointerGuide.strokeStyle\r\n\t\t\tthis.ctx.lineWidth = this.pointerGuide.lineWidth\r\n\r\n\t\t\t// Draw from the center of the wheel outwards past the wheel outer radius.\r\n\t\t\tthis.ctx.beginPath()\r\n\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\r\n\t\t\tthis.ctx.lineTo(this.centerX, -(this.outerRadius / 4))\r\n\r\n\t\t\tthis.ctx.stroke()\r\n\t\t\tthis.ctx.restore()\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function takes an image such as PNG and draws it on the canvas making its center at the centerX and center for the wheel.\r\n\t// ====================================================================================================================\r\n\tdrawWheelImage() {\r\n\t\t// Double check the wheelImage property of this class is not null. This does not actually detect that an image\r\n\t\t// source was set and actually loaded so might get error if this is not the case. This is why the initial call\r\n\t\t// to draw() should be done from a wheelImage.onload callback as detailed in example documentation.\r\n\t\tif (this.wheelImage != null) {\r\n\t\t\t// Work out the correct X and Y to draw the image at. We need to get the center point of the image\r\n\t\t\t// aligned over the center point of the wheel, we can't just place it at 0, 0.\r\n\t\t\tvar imageLeft = this.centerX - this.wheelImage.height / 2\r\n\t\t\tvar imageTop = this.centerY - this.wheelImage.width / 2\r\n\r\n\t\t\t// Rotate and then draw the wheel.\r\n\t\t\t// We must rotate by the rotationAngle before drawing to ensure that image wheels will spin.\r\n\t\t\tthis.ctx.save()\r\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle))\r\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\tthis.ctx.drawImage(this.wheelImage, imageLeft, imageTop)\r\n\r\n\t\t\tthis.ctx.restore()\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function draws the wheel on the canvas by rendering the image for each segment.\r\n\t// ====================================================================================================================\r\n\tdrawSegmentImages() {\r\n\t\t// Again check have context in case this function was called directly and not via draw function.\r\n\t\tif (this.ctx) {\r\n\t\t\t// Draw the segments if there is at least one in the segments array.\r\n\t\t\tif (this.segments) {\r\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\r\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\r\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\r\n\t\t\t\t\t// Get the segment object as we need it to read options from.\r\n\t\t\t\t\tvar seg = this.segments[x]\r\n\r\n\t\t\t\t\t// Check image has loaded so a property such as height has a value.\r\n\t\t\t\t\tif (seg.imgData.height) {\r\n\t\t\t\t\t\t// Work out the correct X and Y to draw the image at which depends on the direction of the image.\r\n\t\t\t\t\t\t// Images can be created in 4 directions. North, South, East, West.\r\n\t\t\t\t\t\t// North: Outside at top, inside at bottom. Sits evenly over the 0 degrees angle.\r\n\t\t\t\t\t\t// South: Outside at bottom, inside at top. Sits evenly over the 180 degrees angle.\r\n\t\t\t\t\t\t// East: Outside at right, inside at left. Sits evenly over the 90 degrees angle.\r\n\t\t\t\t\t\t// West: Outside at left, inside at right. Sits evenly over the 270 degrees angle.\r\n\t\t\t\t\t\tvar imageLeft = 0\r\n\t\t\t\t\t\tvar imageTop = 0\r\n\t\t\t\t\t\tvar imageAngle = 0\r\n\t\t\t\t\t\tvar imageDirection = ''\r\n\r\n\t\t\t\t\t\tif (seg.imageDirection !== null) imageDirection = seg.imageDirection\r\n\t\t\t\t\t\telse imageDirection = this.imageDirection\r\n\r\n\t\t\t\t\t\tif (imageDirection == 'S') {\r\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 180 degrees point.\r\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\r\n\r\n\t\t\t\t\t\t\t// Top so image starts at the centerY.\r\n\t\t\t\t\t\t\timageTop = this.centerY\r\n\r\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\r\n\t\t\t\t\t\t\t// Here we add 180 to the angle to the segment is poistioned correctly.\r\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 180 + (seg.endAngle - seg.startAngle) / 2\r\n\t\t\t\t\t\t} else if (imageDirection == 'E') {\r\n\t\t\t\t\t\t\t// Left set so image starts and the center point.\r\n\t\t\t\t\t\t\timageLeft = this.centerX\r\n\r\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 90 degree point.\r\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\r\n\r\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\r\n\t\t\t\t\t\t\t// this time we need to add 270 to that to the segment is rendered the correct place.\r\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 270 + (seg.endAngle - seg.startAngle) / 2\r\n\t\t\t\t\t\t} else if (imageDirection == 'W') {\r\n\t\t\t\t\t\t\t// Left is the centerX minus the width of the image.\r\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width\r\n\r\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 270 degree point.\r\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\r\n\r\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\r\n\t\t\t\t\t\t\t// this time we need to add 90 to that to the segment is rendered the correct place.\r\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 90 + (seg.endAngle - seg.startAngle) / 2\r\n\t\t\t\t\t\t} // North is the default.\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 0 degrees point.\r\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\r\n\r\n\t\t\t\t\t\t\t// Top so image is its height out (above) the center point.\r\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height\r\n\r\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\r\n\t\t\t\t\t\t\t// this sits it half/half over the center angle of the segment.\r\n\t\t\t\t\t\t\timageAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// --------------------------------------------------\r\n\t\t\t\t\t\t// Rotate to the position of the segment and then draw the image.\r\n\t\t\t\t\t\tthis.ctx.save()\r\n\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\r\n\t\t\t\t\t\t// So math here is the rotation angle of the wheel plus half way between the start and end angle of the segment.\r\n\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle + imageAngle))\r\n\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t\t\t// Draw the image.\r\n\t\t\t\t\t\tthis.ctx.drawImage(seg.imgData, imageLeft, imageTop)\r\n\r\n\t\t\t\t\t\tthis.ctx.restore()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.log('Segment ' + x + ' imgData is not loaded')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function draws the wheel on the page by rendering the segments on the canvas.\r\n\t// ====================================================================================================================\r\n\tdrawSegments() {\r\n\t\t// Again check have context in case this function was called directly and not via draw function.\r\n\t\tif (this.ctx) {\r\n\t\t\t// Draw the segments if there is at least one in the segments array.\r\n\t\t\tif (this.segments) {\r\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\r\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\r\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\r\n\t\t\t\t\t// Get the segment object as we need it to read options from.\r\n\t\t\t\t\tvar seg = this.segments[x]\r\n\r\n\t\t\t\t\tvar fillStyle\r\n\t\t\t\t\tvar lineWidth\r\n\t\t\t\t\tvar strokeStyle\r\n\r\n\t\t\t\t\t// Set the variables that defined in the segment, or use the default options.\r\n\t\t\t\t\tif (seg.fillStyle !== null) fillStyle = seg.fillStyle\r\n\t\t\t\t\telse fillStyle = this.fillStyle\r\n\r\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\r\n\r\n\t\t\t\t\tif (seg.lineWidth !== null) lineWidth = seg.lineWidth\r\n\t\t\t\t\telse lineWidth = this.lineWidth\r\n\r\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\r\n\r\n\t\t\t\t\tif (seg.strokeStyle !== null) strokeStyle = seg.strokeStyle\r\n\t\t\t\t\telse strokeStyle = this.strokeStyle\r\n\r\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\r\n\r\n\t\t\t\t\t// Check there is a strokeStyle or fillStyle, if either the the segment is invisible so should not\r\n\t\t\t\t\t// try to draw it otherwise a path is began but not ended.\r\n\t\t\t\t\tif (strokeStyle || fillStyle) {\r\n\t\t\t\t\t\t// ----------------------------------\r\n\t\t\t\t\t\t// Begin a path as the segment consists of an arc and 2 lines.\r\n\t\t\t\t\t\tthis.ctx.beginPath()\r\n\r\n\t\t\t\t\t\t// If don't have an inner radius then move to the center of the wheel as we want a line out from the center\r\n\t\t\t\t\t\t// to the start of the arc for the outside of the wheel when we arc. Canvas will draw the connecting line for us.\r\n\t\t\t\t\t\tif (!this.innerRadius) {\r\n\t\t\t\t\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t//++ do need to draw the starting line in the correct x + y based on the start angle\r\n\t\t\t\t\t\t\t//++ otherwise as seen when the wheel does not use up 360 the starting segment is missing the stroked side,\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Draw the outer arc of the segment clockwise in direction -->\r\n\t\t\t\t\t\tthis.ctx.arc(\r\n\t\t\t\t\t\t\tthis.centerX,\r\n\t\t\t\t\t\t\tthis.centerY,\r\n\t\t\t\t\t\t\tthis.outerRadius,\r\n\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\r\n\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\r\n\t\t\t\t\t\t\tfalse\r\n\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\tif (this.innerRadius) {\r\n\t\t\t\t\t\t\t// Draw another arc, this time anticlockwise <-- at the innerRadius between the end angle and the start angle.\r\n\t\t\t\t\t\t\t// Canvas will draw a connecting line from the end of the outer arc to the beginning of the inner arc completing the shape.\r\n\r\n\t\t\t\t\t\t\t//++ Think the reason the lines are thinner for 2 of the segments is because the thing auto chops part of it\r\n\t\t\t\t\t\t\t//++ when doing the next one. Again think that actually drawing the lines will help.\r\n\r\n\t\t\t\t\t\t\tthis.ctx.arc(\r\n\t\t\t\t\t\t\t\tthis.centerX,\r\n\t\t\t\t\t\t\t\tthis.centerY,\r\n\t\t\t\t\t\t\t\tthis.innerRadius,\r\n\t\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\r\n\t\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\r\n\t\t\t\t\t\t\t\ttrue\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// If no inner radius then we draw a line back to the center of the wheel.\r\n\t\t\t\t\t\t\tthis.ctx.lineTo(this.centerX, this.centerY)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Fill and stroke the segment. Only do either if a style was specified, if the style is null then\r\n\t\t\t\t\t\t// we assume the developer did not want that particular thing.\r\n\t\t\t\t\t\t// For example no stroke style so no lines to be drawn.\r\n\t\t\t\t\t\tif (fillStyle) this.ctx.fill()\r\n\r\n\t\t\t\t\t\tif (strokeStyle) this.ctx.stroke()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This draws the text on the segments using the specified text options.\r\n\t// ====================================================================================================================\r\n\tdrawSegmentText() {\r\n\t\t// Again only draw the text if have a canvas context.\r\n\t\tif (this.ctx) {\r\n\t\t\t// Declare variables to hold the values. These are populated either with the value for the specific segment,\r\n\t\t\t// or if not specified then the global default value.\r\n\t\t\tvar fontFamily\r\n\t\t\tvar fontSize\r\n\t\t\tvar fontWeight\r\n\t\t\tvar orientation\r\n\t\t\tvar alignment\r\n\t\t\tvar direction\r\n\t\t\tvar margin\r\n\t\t\tvar fillStyle\r\n\t\t\tvar strokeStyle\r\n\t\t\tvar lineWidth\r\n\t\t\tvar fontSetting\r\n\r\n\t\t\t// Loop though all the segments.\r\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\r\n\t\t\t\t// Save the context so it is certain that each segment text option will not affect the other.\r\n\t\t\t\tthis.ctx.save()\r\n\r\n\t\t\t\t// Get the segment object as we need it to read options from.\r\n\t\t\t\tvar seg = this.segments[x]\r\n\r\n\t\t\t\t// Check is text as no point trying to draw if there is no text to render.\r\n\t\t\t\tif (seg.text) {\r\n\t\t\t\t\t// Set values to those for the specific segment or use global default if null.\r\n\t\t\t\t\tif (seg.textFontFamily !== null) fontFamily = seg.textFontFamily\r\n\t\t\t\t\telse fontFamily = this.textFontFamily\r\n\t\t\t\t\tif (seg.textFontSize !== null) fontSize = seg.textFontSize\r\n\t\t\t\t\telse fontSize = this.textFontSize\r\n\t\t\t\t\tif (seg.textFontWeight !== null) fontWeight = seg.textFontWeight\r\n\t\t\t\t\telse fontWeight = this.textFontWeight\r\n\t\t\t\t\tif (seg.textOrientation !== null) orientation = seg.textOrientation\r\n\t\t\t\t\telse orientation = this.textOrientation\r\n\t\t\t\t\tif (seg.textAlignment !== null) alignment = seg.textAlignment\r\n\t\t\t\t\telse alignment = this.textAlignment\r\n\t\t\t\t\tif (seg.textDirection !== null) direction = seg.textDirection\r\n\t\t\t\t\telse direction = this.textDirection\r\n\t\t\t\t\tif (seg.textMargin !== null) margin = seg.textMargin\r\n\t\t\t\t\telse margin = this.textMargin\r\n\t\t\t\t\tif (seg.textFillStyle !== null) fillStyle = seg.textFillStyle\r\n\t\t\t\t\telse fillStyle = this.textFillStyle\r\n\t\t\t\t\tif (seg.textStrokeStyle !== null) strokeStyle = seg.textStrokeStyle\r\n\t\t\t\t\telse strokeStyle = this.textStrokeStyle\r\n\t\t\t\t\tif (seg.textLineWidth !== null) lineWidth = seg.textLineWidth\r\n\t\t\t\t\telse lineWidth = this.textLineWidth\r\n\r\n\t\t\t\t\t// ------------------------------\r\n\t\t\t\t\t// We need to put the font bits together in to one string.\r\n\t\t\t\t\tfontSetting = ''\r\n\r\n\t\t\t\t\tif (fontWeight != null) fontSetting += fontWeight + ' '\r\n\r\n\t\t\t\t\tif (fontSize != null) fontSetting += fontSize + 'px ' // Fonts on canvas are always a px value.\r\n\r\n\t\t\t\t\tif (fontFamily != null) fontSetting += fontFamily\r\n\r\n\t\t\t\t\t// Now set the canvas context to the decided values.\r\n\t\t\t\t\tthis.ctx.font = fontSetting\r\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\r\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\r\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\r\n\r\n\t\t\t\t\t// Split the text in to multiple lines on the \\n character.\r\n\t\t\t\t\tvar lines = seg.text.split('\\n')\r\n\r\n\t\t\t\t\t// Figure out the starting offset for the lines as when there are multiple lines need to center the text\r\n\t\t\t\t\t// vertically in the segment (when thinking of normal horozontal text).\r\n\t\t\t\t\tvar lineOffset = 0 - fontSize * (lines.length / 2) + fontSize / 2\r\n\r\n\t\t\t\t\t// The offset works great for horozontal and vertial text, also centered curved. But when the text is curved\r\n\t\t\t\t\t// and the alignment is outer then the multiline text should not have some text outside the wheel. Same if inner curved.\r\n\t\t\t\t\tif (orientation == 'curved' && (alignment == 'inner' || alignment == 'outer')) {\r\n\t\t\t\t\t\tlineOffset = 0\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (var i = 0; i < lines.length; i++) {\r\n\t\t\t\t\t\t// ---------------------------------\r\n\t\t\t\t\t\t// If direction is reversed then do things differently than if normal (which is the default - see further down)\r\n\t\t\t\t\t\tif (direction == 'reversed') {\r\n\t\t\t\t\t\t\t// When drawing reversed or 'upside down' we need to do some trickery on our part.\r\n\t\t\t\t\t\t\t// The canvas text rendering function still draws the text left to right and the correct way up,\r\n\t\t\t\t\t\t\t// so we need to overcome this with rotating the opposite side of the wheel the correct way up then pulling the text\r\n\t\t\t\t\t\t\t// through the center point to the correct segment it is supposed to be on.\r\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'right'\r\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'left'\r\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\r\n\r\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\r\n\r\n\t\t\t\t\t\t\t\t// Work out the angle to rotate the wheel, this is in the center of the segment but on the opposite side of the wheel which is why do -180.\r\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\r\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90 - 180\r\n\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\tthis.ctx.save()\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\r\n\t\t\t\t\t\t\t\t\t// In reversed state the margin is subtracted from the innerX.\r\n\t\t\t\t\t\t\t\t\t// When inner the inner radius also comes in to play.\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\r\n\t\t\t\t\t\t\t\t\t// In reversed state the position is the center minus the radius + the margin for outer aligned text.\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// In reversed state the everything in minused.\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\r\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\r\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\r\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\r\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tthis.ctx.restore()\r\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\r\n\t\t\t\t\t\t\t\t// See normal code further down for comments on how it works, this is similar by plus/minus is reversed.\r\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\r\n\r\n\t\t\t\t\t\t\t\t// In reversed mode this are reversed.\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'top'\r\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'bottom'\r\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\r\n\r\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2 - 180\r\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\r\n\r\n\t\t\t\t\t\t\t\tthis.ctx.save()\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY + this.outerRadius - margin\r\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY + this.innerRadius + margin\r\n\r\n\t\t\t\t\t\t\t\t// I have found that the text looks best when a fraction of the font size is shaved off.\r\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\r\n\r\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\r\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\r\n\t\t\t\t\t\t\t\t\t// In reversed mode outer means text in 6 o'clock segment sits at bottom of the wheel and we draw up.\r\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\r\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\r\n\t\t\t\t\t\t\t\t\t// In reversed mode inner text is drawn from top of segment at 6 o'clock position to bottom of the wheel.\r\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\r\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\r\n\t\t\t\t\t\t\t\t\t// Again for reversed this is the opposite of before.\r\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\r\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\r\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\r\n\r\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\r\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tvar yPos =\r\n\t\t\t\t\t\t\t\t\t\tthis.centerY +\r\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\r\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\r\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment +\r\n\t\t\t\t\t\t\t\t\t\tmargin\r\n\r\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\r\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tthis.ctx.restore()\r\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\r\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc,\r\n\t\t\t\t\t\t\t\t// so we need to do this ourselves.\r\n\t\t\t\t\t\t\t\tvar radius = 0\r\n\r\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\r\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\r\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\r\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\r\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\r\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\r\n\r\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\r\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\r\n\t\t\t\t\t\t\t\t\tradius -= fontSize * (lines.length - 1)\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\r\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\r\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\r\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\r\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\r\n\t\t\t\t\t\t\t\tvar drawAngle = 0\r\n\r\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\r\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\r\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\r\n\r\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\r\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\r\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\r\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\r\n\r\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\r\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\r\n\r\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\r\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\r\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\r\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\r\n\r\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\r\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\r\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\r\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\r\n\r\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\r\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\r\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\r\n\r\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centered.\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// ----------------------\r\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\r\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\r\n\r\n\t\t\t\t\t\t\t\t// And as with other 'reverse' text direction functions we need to subtract 180 degrees from the angle\r\n\t\t\t\t\t\t\t\t// because when it comes to draw the characters in the loop below we add the radius instead of subtract it.\r\n\t\t\t\t\t\t\t\tdrawAngle -= 180\r\n\r\n\t\t\t\t\t\t\t\t// ----------------------\r\n\t\t\t\t\t\t\t\t// Now the drawing itself.\r\n\t\t\t\t\t\t\t\t// In reversed direction mode we loop through the characters in the text backwards in order for them to appear on screen correctly\r\n\t\t\t\t\t\t\t\tfor (c = lines[i].length; c >= 0; c--) {\r\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\r\n\r\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\r\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\r\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t\t\t\t\t\t// Now draw the character directly below the center point of the wheel at the appropriate radius.\r\n\t\t\t\t\t\t\t\t\t// Note in the reversed mode we add the radius to the this.centerY instead of subtract.\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY + radius + lineOffset)\r\n\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY + radius + lineOffset)\r\n\r\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\r\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\r\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\r\n\r\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Normal direction so do things normally.\r\n\t\t\t\t\t\t\t// Check text orientation, of horizontal then reasonably straight forward, if vertical then a bit more work to do.\r\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\r\n\t\t\t\t\t\t\t\t// Based on the text alignment, set the correct value in the context.\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'left'\r\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'right'\r\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\r\n\r\n\t\t\t\t\t\t\t\t// Set this too.\r\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\r\n\r\n\t\t\t\t\t\t\t\t// Work out the angle around the wheel to draw the text at, which is simply in the middle of the segment the text is for.\r\n\t\t\t\t\t\t\t\t// The rotation angle is added in to correct the annoyance with the canvas arc drawing functions which put the 0 degrees at the 3 oclock\r\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\r\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90\r\n\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\t// We need to rotate in order to draw the text because it is output horizontally, so to\r\n\t\t\t\t\t\t\t\t// place correctly around the wheel for all but a segment at 3 o'clock we need to rotate.\r\n\t\t\t\t\t\t\t\tthis.ctx.save()\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t\t\t\t\t// --------------------------\r\n\t\t\t\t\t\t\t\t// Draw the text based on its alignment adding margin if inner or outer.\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\r\n\t\t\t\t\t\t\t\t\t// Inner means that the text is aligned with the inner of the wheel. If looking at a segment in in the 3 o'clock position\r\n\t\t\t\t\t\t\t\t\t// it would look like the text is left aligned within the segment.\r\n\r\n\t\t\t\t\t\t\t\t\t// Because the segments are smaller towards the inner of the wheel, in order for the text to fit is is a good idea that\r\n\t\t\t\t\t\t\t\t\t// a margin is added which pushes the text towards the outer a bit.\r\n\r\n\t\t\t\t\t\t\t\t\t// The inner radius also needs to be taken in to account as when inner aligned.\r\n\r\n\t\t\t\t\t\t\t\t\t// If fillstyle is set the draw the text filled in.\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\t\t// If stroke style is set draw the text outline.\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\r\n\t\t\t\t\t\t\t\t\t// Outer means the text is aligned with the outside of the wheel, so if looking at a segment in the 3 o'clock position\r\n\t\t\t\t\t\t\t\t\t// it would appear the text is right aligned. To position we add the radius of the wheel in to the equation\r\n\t\t\t\t\t\t\t\t\t// and subtract the margin this time, rather than add it.\r\n\r\n\t\t\t\t\t\t\t\t\t// I don't understand why, but in order of the text to render correctly with stroke and fill, the stroke needs to\r\n\t\t\t\t\t\t\t\t\t// come first when drawing outer, rather than second when doing inner.\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// In this case the text is to drawn centred in the segment.\r\n\t\t\t\t\t\t\t\t\t// Typically no margin is required, however even though centred the text can look closer to the inner of the wheel\r\n\t\t\t\t\t\t\t\t\t// due to the way the segments narrow in (is optical effect), so if a margin is specified it is placed on the inner\r\n\t\t\t\t\t\t\t\t\t// side so the text is pushed towards the outer.\r\n\r\n\t\t\t\t\t\t\t\t\t// If stoke style the stroke the text.\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\r\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\r\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\r\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\r\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\r\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\r\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Restore the context so that wheel is returned to original position.\r\n\t\t\t\t\t\t\t\tthis.ctx.restore()\r\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\r\n\t\t\t\t\t\t\t\t// If vertical then we need to do this ourselves because as far as I am aware there is no option built in to html canvas\r\n\t\t\t\t\t\t\t\t// which causes the text to draw downwards or upwards one character after another.\r\n\r\n\t\t\t\t\t\t\t\t// In this case the textAlign is always center, but the baseline is either top or bottom\r\n\t\t\t\t\t\t\t\t// depending on if inner or outer alignment has been specified.\r\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\r\n\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'bottom'\r\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'top'\r\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\r\n\r\n\t\t\t\t\t\t\t\t// The angle to draw the text at is halfway between the end and the starting angle of the segment.\r\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2\r\n\r\n\t\t\t\t\t\t\t\t// Ensure the rotation angle of the wheel is added in, otherwise the test placement won't match\r\n\t\t\t\t\t\t\t\t// the segments they are supposed to be for.\r\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\r\n\r\n\t\t\t\t\t\t\t\t// Rotate so can begin to place the text.\r\n\t\t\t\t\t\t\t\tthis.ctx.save()\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\r\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t\t\t\t\t// Work out the position to start drawing in based on the alignment.\r\n\t\t\t\t\t\t\t\t// If outer then when considering a segment at the 12 o'clock position want to start drawing down from the top of the wheel.\r\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY - this.outerRadius + margin\r\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY - this.innerRadius - margin\r\n\r\n\t\t\t\t\t\t\t\t// We need to know how much to move the y axis each time.\r\n\t\t\t\t\t\t\t\t// This is not quite simply the font size as that puts a larger gap in between the letters\r\n\t\t\t\t\t\t\t\t// than expected, especially with monospace fonts. I found that shaving a little off makes it look \"right\".\r\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\r\n\r\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\r\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\r\n\t\t\t\t\t\t\t\t\t// For this alignment we draw down from the top of a segment at the 12 o'clock position to simply\r\n\t\t\t\t\t\t\t\t\t// loop though the characters in order.\r\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\r\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\r\n\t\t\t\t\t\t\t\t\t// Here we draw from the inner of the wheel up, but in order for the letters in the text text to\r\n\t\t\t\t\t\t\t\t\t// remain in the correct order when reading, we actually need to loop though the text characters backwards.\r\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\r\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\r\n\t\t\t\t\t\t\t\t\t// This is the most complex of the three as we need to draw the text top down centred between the inner and outer of the wheel.\r\n\t\t\t\t\t\t\t\t\t// So logically we have to put the middle character of the text in the center then put the others each side of it.\r\n\t\t\t\t\t\t\t\t\t// In reality that is a really bad way to do it, we can achieve the same if not better positioning using a\r\n\t\t\t\t\t\t\t\t\t// variation on the method used for the rendering of outer aligned text once we have figured out the height of the text.\r\n\r\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\r\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\r\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\r\n\r\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\r\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Now work out where to start rendering the string. This is half way between the inner and outer of the wheel, with the\r\n\t\t\t\t\t\t\t\t\t// centerAdjustment included to correctly position texts with more than one character over the center.\r\n\t\t\t\t\t\t\t\t\t// If there is a margin it is used to push the text away from the center of the wheel.\r\n\t\t\t\t\t\t\t\t\tvar yPos =\r\n\t\t\t\t\t\t\t\t\t\tthis.centerY -\r\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\r\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\r\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment -\r\n\t\t\t\t\t\t\t\t\t\tmargin\r\n\r\n\t\t\t\t\t\t\t\t\t// Now loop and draw just like outer text rendering.\r\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\r\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\r\n\r\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tthis.ctx.restore()\r\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\r\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc, so\r\n\t\t\t\t\t\t\t\t// we need to do this ourselves.\r\n\t\t\t\t\t\t\t\tvar radius = 0\r\n\r\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\r\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\r\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\r\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\r\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\r\n\r\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\r\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\r\n\t\t\t\t\t\t\t\t\tradius += fontSize * (lines.length - 1)\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\r\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\r\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\r\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\r\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\r\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\r\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\r\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\r\n\t\t\t\t\t\t\t\tvar drawAngle = 0\r\n\r\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\r\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\r\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\r\n\r\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\r\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\r\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\r\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\r\n\r\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\r\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\r\n\r\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\r\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\r\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\r\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\r\n\r\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\r\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\r\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\r\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\r\n\r\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\r\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\r\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\r\n\r\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centred.\r\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// ----------------------\r\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\r\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\r\n\r\n\t\t\t\t\t\t\t\t// ----------------------\r\n\t\t\t\t\t\t\t\t// Now the drawing itself.\r\n\t\t\t\t\t\t\t\t// Loop for each character in the text.\r\n\t\t\t\t\t\t\t\tfor (c = 0; c < lines[i].length; c++) {\r\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\r\n\r\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\r\n\r\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\r\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\r\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\r\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\r\n\r\n\t\t\t\t\t\t\t\t\t// Now draw the character directly above the center point of the wheel at the appropriate radius.\r\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY - radius + lineOffset)\r\n\r\n\t\t\t\t\t\t\t\t\tif (fillStyle)\r\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY - radius + lineOffset)\r\n\r\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\r\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\r\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\r\n\r\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Increment this ready for the next time.\r\n\t\t\t\t\t\tlineOffset += fontSize\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Restore so all text options are reset ready for the next text.\r\n\t\t\t\tthis.ctx.restore()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Converts degrees to radians which is what is used when specifying the angles on HTML5 canvas arcs.\r\n\t// ====================================================================================================================\r\n\tdegToRad(d) {\r\n\t\treturn d * 0.0174532925199432957\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function sets the center location of the wheel, saves a function call to set x then y.\r\n\t// ====================================================================================================================\r\n\tsetCenter(x, y) {\r\n\t\tthis.centerX = x\r\n\t\tthis.centerY = y\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function allows a segment to be added to the wheel. The position of the segment is optional,\r\n\t// if not specified the new segment will be added to the end of the wheel.\r\n\t// ====================================================================================================================\r\n\taddSegment(options, position) {\r\n\t\t// Create a new segment object passing the options in.\r\n\t\tnewSegment = new Segment(options)\r\n\r\n\t\t// Increment the numSegments property of the class since new segment being added.\r\n\t\tthis.numSegments++\r\n\t\tvar segmentPos\r\n\r\n\t\t// Work out where to place the segment, the default is simply as a new segment at the end of the wheel.\r\n\t\tif (typeof position !== 'undefined') {\r\n\t\t\t// Because we need to insert the segment at this position, not overwrite it, we need to move all segments after this\r\n\t\t\t// location along one in the segments array, before finally adding this new segment at the specified location.\r\n\t\t\tfor (var x = this.numSegments; x > position; x--) {\r\n\t\t\t\tthis.segments[x] = this.segments[x - 1]\r\n\t\t\t}\r\n\r\n\t\t\tthis.segments[position] = newSegment\r\n\t\t\tsegmentPos = position\r\n\t\t} else {\r\n\t\t\tthis.segments[this.numSegments] = newSegment\r\n\t\t\tsegmentPos = this.numSegments\r\n\t\t}\r\n\r\n\t\t// Since a segment has been added the segment sizes need to be re-computed so call function to do this.\r\n\t\tthis.updateSegmentSizes()\r\n\r\n\t\t// Return the segment object just created in the wheel (JavaScript will return it by reference), so that\r\n\t\t// further things can be done with it by the calling code if desired.\r\n\t\treturn this.segments[segmentPos]\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function must be used if the canvasId is changed as we also need to get the context of the new canvas.\r\n\t// ====================================================================================================================\r\n\tsetCanvasId(canvasId) {\r\n\t\tif (canvasId) {\r\n\t\t\tthis.canvasId = canvasId\r\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\r\n\r\n\t\t\tif (this.canvas) {\r\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.canvasId = null\r\n\t\t\tthis.ctx = null\r\n\t\t\tthis.canvas = null\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function deletes the specified segment from the wheel by removing it from the segments array.\r\n\t// It then sorts out the other bits such as update of the numSegments.\r\n\t// ====================================================================================================================\r\n\tdeleteSegment(position) {\r\n\t\t// There needs to be at least one segment in order for the wheel to draw, so only allow delete if there\r\n\t\t// is more than one segment currently left in the wheel.\r\n\r\n\t\t//++ check that specifying a position that does not exist - say 10 in a 6 segment wheel does not cause issues.\r\n\t\tif (this.numSegments > 1) {\r\n\t\t\t// If the position of the segment to remove has been specified.\r\n\t\t\tif (typeof position !== 'undefined') {\r\n\t\t\t\t// The array is to be shortened so we need to move all segments after the one\r\n\t\t\t\t// to be removed down one so there is no gap.\r\n\t\t\t\tfor (var x = position; x < this.numSegments; x++) {\r\n\t\t\t\t\tthis.segments[x] = this.segments[x + 1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Unset the last item in the segments array since there is now one less.\r\n\t\t\tthis.segments[this.numSegments] = undefined\r\n\r\n\t\t\t// Decrement the number of segments,\r\n\t\t\t// then call function to update the segment sizes.\r\n\t\t\tthis.numSegments--\r\n\t\t\tthis.updateSegmentSizes()\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function takes the x an the y of a mouse event, such as click or move, and converts the x and the y in to\r\n\t// co-ordinates on the canvas as the raw values are the x and the y from the top and left of the user's browser.\r\n\t// ====================================================================================================================\r\n\twindowToCanvas(x, y) {\r\n\t\tvar bbox = this.canvas.getBoundingClientRect()\r\n\r\n\t\treturn {\r\n\t\t\tx: Math.floor(x - bbox.left * (this.canvas.width / bbox.width)),\r\n\t\t\ty: Math.floor(y - bbox.top * (this.canvas.height / bbox.height)),\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// This function returns the segment object located at the specified x and y coordinates on the canvas.\r\n\t// It is used to allow things to be done with a segment clicked by the user, such as highlight, display or change some values, etc.\r\n\t// ====================================================================================================================\r\n\tgetSegmentAt(x, y) {\r\n\t\tvar foundSegment = null\r\n\r\n\t\t// Call function to return segment number.\r\n\t\tvar segmentNumber = this.getSegmentNumberAt(x, y)\r\n\r\n\t\t// If found one then set found segment to pointer to the segment object.\r\n\t\tif (segmentNumber !== null) {\r\n\t\t\tfoundSegment = this.segments[segmentNumber]\r\n\t\t}\r\n\r\n\t\treturn foundSegment\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Returns the number of the segment clicked instead of the segment object.\r\n\t// ====================================================================================================================\r\n\tgetSegmentNumberAt(x, y) {\r\n\t\t// KNOWN ISSUE: this does not work correct if the canvas is scaled using css, or has padding, border.\r\n\t\t// @TODO see if can find a solution at some point, check windowToCanvas working as needed, then below.\r\n\r\n\t\t// Call function above to convert the raw x and y from the user's browser to canvas coordinates\r\n\t\t// i.e. top and left is top and left of canvas, not top and left of the user's browser.\r\n\t\tvar loc = this.windowToCanvas(x, y)\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// Now start the process of working out the segment clicked.\r\n\t\t// First we need to figure out the angle of an imaginary line between the centerX and centerY of the wheel and\r\n\t\t// the X and Y of the location (for example a mouse click).\r\n\t\tvar topBottom\r\n\t\tvar leftRight\r\n\t\tvar adjacentSideLength\r\n\t\tvar oppositeSideLength\r\n\t\tvar hypotenuseSideLength\r\n\r\n\t\t// We will use right triangle maths with the TAN function.\r\n\t\t// The start of the triangle is the wheel center, the adjacent side is along the x axis, and the opposite side is along the y axis.\r\n\r\n\t\t// We only ever use positive numbers to work out the triangle and the center of the wheel needs to be considered as 0 for the numbers\r\n\t\t// in the maths which is why there is the subtractions below. We also remember what quadrant of the wheel the location is in as we\r\n\t\t// need this information later to add 90, 180, 270 degrees to the angle worked out from the triangle to get the position around a 360 degree wheel.\r\n\t\tif (loc.x > this.centerX) {\r\n\t\t\tadjacentSideLength = loc.x - this.centerX\r\n\t\t\tleftRight = 'R' // Location is in the right half of the wheel.\r\n\t\t} else {\r\n\t\t\tadjacentSideLength = this.centerX - loc.x\r\n\t\t\tleftRight = 'L' // Location is in the left half of the wheel.\r\n\t\t}\r\n\r\n\t\tif (loc.y > this.centerY) {\r\n\t\t\toppositeSideLength = loc.y - this.centerY\r\n\t\t\ttopBottom = 'B' // Bottom half of wheel.\r\n\t\t} else {\r\n\t\t\toppositeSideLength = this.centerY - loc.y\r\n\t\t\ttopBottom = 'T' // Top Half of wheel.\r\n\t\t}\r\n\r\n\t\t// Now divide opposite by adjacent to get tan value.\r\n\t\tvar tanVal = oppositeSideLength / adjacentSideLength\r\n\r\n\t\t// Use the tan function and convert results to degrees since that is what we work with.\r\n\t\tvar result = (Math.atan(tanVal) * 180) / Math.PI\r\n\t\tvar locationAngle = 0\r\n\r\n\t\t// We also need the length of the hypotenuse as later on we need to compare this to the outerRadius of the segment / circle.\r\n\t\thypotenuseSideLength = Math.sqrt(\r\n\t\t\toppositeSideLength * oppositeSideLength + adjacentSideLength * adjacentSideLength\r\n\t\t)\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// Now to make sense around the wheel we need to alter the values based on if the location was in top or bottom half\r\n\t\t// and also right or left half of the wheel, by adding 90, 180, 270 etc. Also for some the initial locationAngle needs to be inverted.\r\n\t\tif (topBottom == 'T' && leftRight == 'R') {\r\n\t\t\tlocationAngle = Math.round(90 - result)\r\n\t\t} else if (topBottom == 'B' && leftRight == 'R') {\r\n\t\t\tlocationAngle = Math.round(result + 90)\r\n\t\t} else if (topBottom == 'B' && leftRight == 'L') {\r\n\t\t\tlocationAngle = Math.round(90 - result + 180)\r\n\t\t} else if (topBottom == 'T' && leftRight == 'L') {\r\n\t\t\tlocationAngle = Math.round(result + 270)\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// And now we have to adjust to make sense when the wheel is rotated from the 0 degrees either\r\n\t\t// positive or negative and it can be many times past 360 degrees.\r\n\t\tif (this.rotationAngle != 0) {\r\n\t\t\tvar rotatedPosition = this.getRotationPosition()\r\n\r\n\t\t\t// So we have this, now we need to alter the locationAngle as a result of this.\r\n\t\t\tlocationAngle = locationAngle - rotatedPosition\r\n\r\n\t\t\t// If negative then take the location away from 360.\r\n\t\t\tif (locationAngle < 0) {\r\n\t\t\t\tlocationAngle = 360 - Math.abs(locationAngle)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------\r\n\t\t// OK, so after all of that we have the angle of a line between the centerX and centerY of the wheel and\r\n\t\t// the X and Y of the location on the canvas where the mouse was clicked. Now time to work out the segment\r\n\t\t// this corresponds to. We can use the segment start and end angles for this.\r\n\t\tvar foundSegmentNumber = null\r\n\r\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\r\n\t\t\t// Due to segments sharing start and end angles, if line is clicked will pick earlier segment.\r\n\t\t\tif (locationAngle >= this.segments[x].startAngle && locationAngle <= this.segments[x].endAngle) {\r\n\t\t\t\t// To ensure that a click anywhere on the canvas in the segment direction will not cause a\r\n\t\t\t\t// segment to be matched, as well as the angles, we need to ensure the click was within the radius\r\n\t\t\t\t// of the segment (or circle if no segment radius).\r\n\r\n\t\t\t\t// If the hypotenuseSideLength (length of location from the center of the wheel) is with the radius\r\n\t\t\t\t// then we can assign the segment to the found segment and break out the loop.\r\n\r\n\t\t\t\t// Have to take in to account hollow wheels (doughnuts) so check is greater than innerRadius as\r\n\t\t\t\t// well as less than or equal to the outerRadius of the wheel.\r\n\t\t\t\tif (hypotenuseSideLength >= this.innerRadius && hypotenuseSideLength <= this.outerRadius) {\r\n\t\t\t\t\tfoundSegmentNumber = x\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Finally return the number.\r\n\t\treturn foundSegmentNumber\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Returns a reference to the segment that is at the location of the pointer on the wheel.\r\n\t// ====================================================================================================================\r\n\tgetIndicatedSegment() {\r\n\t\t// Call function below to work this out and return the prizeNumber.\r\n\t\tvar prizeNumber = this.getIndicatedSegmentNumber()\r\n\r\n\t\t// Then simply return the segment in the segments array at that position.\r\n\t\treturn this.segments[prizeNumber]\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Works out the segment currently pointed to by the pointer of the wheel. Normally called when the spinning has stopped\r\n\t// to work out the prize the user has won. Returns the number of the segment in the segments array.\r\n\t// ====================================================================================================================\r\n\tgetIndicatedSegmentNumber() {\r\n\t\tvar indicatedPrize = 0\r\n\t\tvar rawAngle = this.getRotationPosition()\r\n\r\n\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\r\n\t\t// will not always be at the 12 o'clock 0 degrees location.\r\n\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\r\n\r\n\t\tif (relativeAngle < 0) {\r\n\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\r\n\t\t}\r\n\r\n\t\t// Now we can work out the prize won by seeing what prize segment startAngle and endAngle the relativeAngle is between.\r\n\t\tfor (var x = 1; x < this.segments.length; x++) {\r\n\t\t\tif (relativeAngle >= this.segments[x]['startAngle'] && relativeAngle <= this.segments[x]['endAngle']) {\r\n\t\t\t\tindicatedPrize = x\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn indicatedPrize\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Works out what Pin around the wheel is considered the current one which is the one which just passed the pointer.\r\n\t// Used to work out if the pin has changed during the animation to tigger a sound.\r\n\t// ====================================================================================================================\r\n\tgetCurrentPinNumber() {\r\n\t\tvar currentPin = 0\r\n\r\n\t\tif (this.pins) {\r\n\t\t\tvar rawAngle = this.getRotationPosition()\r\n\r\n\t\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\r\n\t\t\t// will not always be at the 12 o'clock 0 degrees location.\r\n\t\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\r\n\r\n\t\t\tif (relativeAngle < 0) {\r\n\t\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\r\n\t\t\t}\r\n\r\n\t\t\t// Work out the angle of the pins as this is simply 360 / the number of pins as they space evenly around.\r\n\t\t\tvar pinSpacing = 360 / this.pins.number\r\n\t\t\tvar totalPinAngle = 0\r\n\r\n\t\t\t// Now we can work out the pin by seeing what pins relativeAngle is between.\r\n\t\t\tfor (var x = 0; x < this.pins.number; x++) {\r\n\t\t\t\tif (relativeAngle >= totalPinAngle && relativeAngle <= totalPinAngle + pinSpacing) {\r\n\t\t\t\t\tcurrentPin = x\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttotalPinAngle += pinSpacing\r\n\t\t\t}\r\n\r\n\t\t\t// Now if rotating clockwise we must add 1 to the current pin as we want the pin which has just passed\r\n\t\t\t// the pointer to be returned as the current pin, not the start of the one we are between.\r\n\t\t\tif (this.animation.direction == 'clockwise') {\r\n\t\t\t\tcurrentPin++\r\n\r\n\t\t\t\tif (currentPin > this.pins.number) {\r\n\t\t\t\t\tcurrentPin = 0\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn currentPin\r\n\t}\r\n\r\n\t// ==================================================================================================================================================\r\n\t// Returns the rotation angle of the wheel corrected to 0-360 (i.e. removes all the multiples of 360).\r\n\t// ==================================================================================================================================================\r\n\tgetRotationPosition() {\r\n\t\tvar rawAngle = this.rotationAngle // Get current rotation angle of wheel.\r\n\r\n\t\t// If positive work out how many times past 360 this is and then take the floor of this off the rawAngle.\r\n\t\tif (rawAngle >= 0) {\r\n\t\t\tif (rawAngle > 360) {\r\n\t\t\t\t// Get floor of the number of times past 360 degrees.\r\n\t\t\t\tvar timesPast360 = Math.floor(rawAngle / 360)\r\n\r\n\t\t\t\t// Take all this extra off to get just the angle 0-360 degrees.\r\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Is negative, need to take off the extra then convert in to 0-360 degree value\r\n\t\t\t// so if, for example, was -90 then final value will be (360 - 90) = 270 degrees.\r\n\t\t\tif (rawAngle < -360) {\r\n\t\t\t\tvar timesPast360 = Math.ceil(rawAngle / 360) // Ceil when negative.\r\n\r\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360 // Is minus because dealing with negative.\r\n\t\t\t}\r\n\r\n\t\t\trawAngle = 360 + rawAngle // Make in the range 0-360. Is plus because raw is still negative.\r\n\t\t}\r\n\r\n\t\treturn rawAngle\r\n\t}\r\n\r\n\t// ==================================================================================================================================================\r\n\t// This function starts the wheel's animation by using the properties of the animation object of of the wheel to begin the a greensock tween.\r\n\t// ==================================================================================================================================================\r\n\tstartAnimation() {\r\n\t\tif (this.animation) {\r\n\t\t\t// Call function to compute the animation properties.\r\n\t\t\tthis.computeAnimation()\r\n\r\n\t\t\t// Set this global variable to this object as an external function is required to call the draw() function on the wheel\r\n\t\t\t// each loop of the animation as Greensock cannot call the draw function directly on this class.\r\n\t\t\twinwheelToDrawDuringAnimation = this\r\n\r\n\t\t\t// Put together the properties of the greesock animation.\r\n\t\t\tvar properties = new Array(null)\r\n\t\t\tproperties[this.animation.propertyName] = this.animation.propertyValue // Here we set the property to be animated and its value.\r\n\t\t\tproperties['yoyo'] = this.animation.yoyo // Set others.\r\n\t\t\tproperties['repeat'] = this.animation.repeat\r\n\t\t\tproperties['ease'] = this.animation.easing\r\n\t\t\tproperties['onUpdate'] = winwheelAnimationLoop // Call function to re-draw the canvas.\r\n\t\t\tproperties['onComplete'] = winwheelStopAnimation // Call function to perform actions when animation has finished.\r\n\r\n\t\t\t// Do the tween animation passing the properties from the animation object as an array of key => value pairs.\r\n\t\t\t// Keep reference to the tween object in the wheel as that allows pausing, resuming, and stopping while the animation is still running.\r\n\t\t\tthis.tween = TweenMax.to(this, this.animation.duration, properties)\r\n\t\t}\r\n\t}\r\n\r\n\t// ==================================================================================================================================================\r\n\t// Use same function function which needs to be outside the class for the callback when it stops because is finished.\r\n\t// ==================================================================================================================================================\r\n\tstopAnimation(canCallback) {\r\n\t\t// @TODO as part of multiwheel, need to work out how to stop the tween for a single wheel but allow others to continue.\r\n\r\n\t\t// We can kill the animation using our tween object.\r\n\t\tif (winwheelToDrawDuringAnimation) {\r\n\t\t\twinwheelToDrawDuringAnimation.tween.kill()\r\n\r\n\t\t\t// Call the callback function.\r\n\t\t\twinwheelStopAnimation(canCallback)\r\n\t\t}\r\n\r\n\t\t// Ensure the winwheelToDrawDuringAnimation is set to this class.\r\n\t\twinwheelToDrawDuringAnimation = this\r\n\t}\r\n\r\n\t// ==================================================================================================================================================\r\n\t// Pause animation by telling tween to pause.\r\n\t// ==================================================================================================================================================\r\n\tpauseAnimation() {\r\n\t\tif (this.tween) {\r\n\t\t\tthis.tween.pause()\r\n\t\t}\r\n\t}\r\n\r\n\t// ==================================================================================================================================================\r\n\t// Resume the animation by telling tween to continue playing it.\r\n\t// ==================================================================================================================================================\r\n\tresumeAnimation() {\r\n\t\tif (this.tween) {\r\n\t\t\tthis.tween.play()\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Called at the beginning of the startAnimation function and computes the values needed to do the animation\r\n\t// before it starts. This allows the developer to change the animation properties after the wheel has been created\r\n\t// and have the animation use the new values of the animation properties.\r\n\t// ====================================================================================================================\r\n\tcomputeAnimation() {\r\n\t\tif (this.animation) {\r\n\t\t\t// Set the animation parameters for the specified animation type including some sensible defaults if values have not been specified.\r\n\t\t\tif (this.animation.type == 'spinOngoing') {\r\n\t\t\t\t// When spinning the rotationAngle is the wheel property which is animated.\r\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\r\n\r\n\t\t\t\tif (this.animation.spins == null) {\r\n\t\t\t\t\tthis.animation.spins = 5\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.repeat == null) {\r\n\t\t\t\t\tthis.animation.repeat = -1 // -1 means it will repeat forever.\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.easing == null) {\r\n\t\t\t\t\tthis.animation.easing = 'Linear.easeNone'\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.yoyo == null) {\r\n\t\t\t\t\tthis.animation.yoyo = false\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We need to calculate the propertyValue and this is the spins * 360 degrees.\r\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\r\n\r\n\t\t\t\t// If the direction is anti-clockwise then make the property value negative.\r\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\r\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\r\n\t\t\t\t}\r\n\t\t\t} else if (this.animation.type == 'spinToStop') {\r\n\t\t\t\t// Spin to stop the rotation angle is affected.\r\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\r\n\r\n\t\t\t\tif (this.animation.spins == null) {\r\n\t\t\t\t\tthis.animation.spins = 5\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.repeat == null) {\r\n\t\t\t\t\tthis.animation.repeat = 0 // As this is spin to stop we don't normally want it repeated.\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.easing == null) {\r\n\t\t\t\t\tthis.animation.easing = 'Power3.easeOut' // This easing is fast start and slows over time.\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.stopAngle == null) {\r\n\t\t\t\t\t// If the stop angle has not been specified then pick random between 0 and 359.\r\n\t\t\t\t\tthis.animation._stopAngle = Math.floor(Math.random() * 359)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered because the wheel spins past 0 without\r\n\t\t\t\t\t// this it would indicate the prize on the opposite side of the wheel. We aslo need to take in to account\r\n\t\t\t\t\t// the pointerAngle as the stop angle needs to be relative to that.\r\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle + this.pointerAngle\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.yoyo == null) {\r\n\t\t\t\t\tthis.animation.yoyo = false\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\r\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\r\n\r\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\r\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\r\n\r\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\r\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\r\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\r\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\r\n\t\t\t\t}\r\n\t\t\t} else if (this.animation.type == 'spinAndBack') {\r\n\t\t\t\t// This is basically is a spin for a number of times then the animation reverses and goes back to start.\r\n\t\t\t\t// If a repeat is specified then this can be used to make the wheel \"rock\" left and right.\r\n\r\n\t\t\t\t// Again this is a spin so the rotationAngle the property which is animated.\r\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\r\n\r\n\t\t\t\tif (this.animation.spins == null) {\r\n\t\t\t\t\tthis.animation.spins = 5\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.repeat == null) {\r\n\t\t\t\t\tthis.animation.repeat = 1 // This needs to be set to at least 1 in order for the animation to reverse.\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.easing == null) {\r\n\t\t\t\t\tthis.animation.easing = 'Power2.easeInOut' // This is slow at the start and end and fast in the middle.\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.yoyo == null) {\r\n\t\t\t\t\tthis.animation.yoyo = true // This needs to be set to true to have the animation reverse back like a yo-yo.\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.animation.stopAngle == null) {\r\n\t\t\t\t\tthis.animation._stopAngle = 0\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered\r\n\t\t\t\t\t// because the wheel spins past 0 without this it would indicate the\r\n\t\t\t\t\t// prize on the opposite side of the wheel.\r\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\r\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\r\n\r\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\r\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\r\n\r\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\r\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\r\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\r\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\r\n\t\t\t\t}\r\n\t\t\t} else if (this.animation.type == 'custom') {\r\n\t\t\t\t// Do nothing as all values must be set by the developer in the parameters\r\n\t\t\t\t// especially the propertyName and propertyValue.\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Calculates and returns a random stop angle inside the specified segment number. Value will always be 1 degree inside\r\n\t// the start and end of the segment to avoid issue with the segment overlap.\r\n\t// ====================================================================================================================\r\n\tgetRandomForSegment(segmentNumber) {\r\n\t\tvar stopAngle = 0\r\n\r\n\t\tif (segmentNumber) {\r\n\t\t\tif (typeof this.segments[segmentNumber] !== 'undefined') {\r\n\t\t\t\tvar startAngle = this.segments[segmentNumber].startAngle\r\n\t\t\t\tvar endAngle = this.segments[segmentNumber].endAngle\r\n\t\t\t\tvar range = endAngle - startAngle - 2\r\n\r\n\t\t\t\tif (range > 0) {\r\n\t\t\t\t\tstopAngle = startAngle + 1 + Math.floor(Math.random() * range)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log('Segment size is too small to safely get random angle inside it')\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('Segment ' + segmentNumber + ' undefined')\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconsole.log('Segment number not specified')\r\n\t\t}\r\n\r\n\t\treturn stopAngle\r\n\t}\r\n}\r\n\r\n// ====================================================================================================================\r\n// Class for the wheel pins.\r\n// ====================================================================================================================\r\nexport class Pin {\r\n\tconstructor(options) {\r\n\t\tvar defaultOptions = {\r\n\t\t\tvisible: true, // In future there might be some functionality related to the pins even if they are not displayed.\r\n\t\t\tnumber: 36, // The number of pins. These are evenly distributed around the wheel.\r\n\t\t\touterRadius: 3, // Radius of the pins which determines their size.\r\n\t\t\tfillStyle: '#c4376f',//'grey', // Fill colour of the pins.\r\n\t\t\tstrokeStyle: 'black', // Line colour of the pins.\r\n\t\t\tlineWidth: 1, // Line width of the pins.\r\n\t\t\tmargin: 3, // The space between outside edge of the wheel and the pins.\r\n\t\t}\r\n\r\n\t\t// Now loop through the default options and create properties of this class set to the value for\r\n\t\t// the option passed in if a value was, or if not then set the value of the default.\r\n\t\tfor (var key in defaultOptions) {\r\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\r\n\t\t\telse this[key] = defaultOptions[key]\r\n\t\t}\r\n\r\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\r\n\t\tif (options != null) {\r\n\t\t\tfor (var key in options) {\r\n\t\t\t\tif (typeof this[key] === 'undefined') {\r\n\t\t\t\t\tthis[key] = options[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n// ====================================================================================================================\r\n// Class for the wheel spinning animation which like a segment becomes a property of the wheel.\r\n// ====================================================================================================================\r\nexport class Animation {\r\n\tconstructor(options) {\r\n\t\t// Most of these options are null because the defaults are different depending on the type of animation.\r\n\t\tvar defaultOptions = {\r\n\t\t\ttype: 'spinOngoing', // For now there are only supported types are spinOngoing (continuous), spinToStop, spinAndBack, custom.\r\n\t\t\tdirection: 'clockwise', // clockwise or anti-clockwise.\r\n\t\t\tpropertyName: null, // The name of the winning wheel property to be affected by the animation.\r\n\t\t\tpropertyValue: null, // The value the property is to be set to at the end of the animation.\r\n\t\t\tduration: 10, // Duration of the animation.\r\n\t\t\tyoyo: false, // If the animation is to reverse back again i.e. yo-yo.\r\n\t\t\trepeat: null, // The number of times the animation is to repeat, -1 will cause it to repeat forever.\r\n\t\t\teasing: null, // The easing to use for the animation, default is the best for spin to stop. Use Linear.easeNone for no easing.\r\n\t\t\tstopAngle: null, // Used for spinning, the angle at which the wheel is to stop.\r\n\t\t\tspins: null, // Used for spinning, the number of complete 360 degree rotations the wheel is to do.\r\n\t\t\tclearTheCanvas: null, // If set to true the canvas will be cleared before the wheel is re-drawn, false it will not, null the animation will abide by the value of this property for the parent wheel object.\r\n\t\t\tcallbackFinished: null, // Function to callback when the animation has finished.\r\n\t\t\tcallbackBefore: null, // Function to callback before the wheel is drawn each animation loop.\r\n\t\t\tcallbackAfter: null, // Function to callback after the wheel is drawn each animation loop.\r\n\t\t\tcallbackSound: null, // Function to callback if a sound should be triggered on change of segment or pin.\r\n\t\t\tsoundTrigger: 'segment', // Sound trigger type. Default is segment which triggers when segment changes, can be pin if to trigger when pin passes the pointer.\r\n\t\t}\r\n\r\n\t\t// Now loop through the default options and create properties of this class set to the value for\r\n\t\t// the option passed in if a value was, or if not then set the value of the default.\r\n\t\tfor (var key in defaultOptions) {\r\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\r\n\t\t\telse this[key] = defaultOptions[key]\r\n\t\t}\r\n\r\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\r\n\t\tif (options != null) {\r\n\t\t\tfor (var key in options) {\r\n\t\t\t\tif (typeof this[key] === 'undefined') {\r\n\t\t\t\t\tthis[key] = options[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n// ====================================================================================================================\r\n// Class for segments. When creating a json of options can be passed in.\r\n// ====================================================================================================================\r\nexport class Segment {\r\n\tconstructor(options) {\r\n\t\t// Define default options for segments, most are null so that the global defaults for the wheel\r\n\t\t// are used if the values for a particular segment are not specifically set.\r\n\t\tvar defaultOptions = {\r\n\t\t\tsize: null, // Leave null for automatic. Valid values are degrees 0-360. Use percentToDegrees function if needed to convert.\r\n\t\t\ttext: '', // Default is blank.\r\n\t\t\tfillStyle: null, // If null for the rest the global default will be used.\r\n\t\t\tstrokeStyle: null,\r\n\t\t\tlineWidth: null,\r\n\t\t\ttextFontFamily: null,\r\n\t\t\ttextFontSize: null,\r\n\t\t\ttextFontWeight: null,\r\n\t\t\ttextOrientation: null,\r\n\t\t\ttextAlignment: null,\r\n\t\t\ttextDirection: null,\r\n\t\t\ttextMargin: null,\r\n\t\t\ttextFillStyle: null,\r\n\t\t\ttextStrokeStyle: null,\r\n\t\t\ttextLineWidth: null,\r\n\t\t\timage: null, // Name/path to the image\r\n\t\t\timageDirection: null, // Direction of the image, can be set globally for the whole wheel.\r\n\t\t\timgData: null, // Image object created here and loaded with image data.\r\n\t\t}\r\n\r\n\t\t// Now loop through the default options and create properties of this class set to the value for\r\n\t\t// the option passed in if a value was, or if not then set the value of the default.\r\n\t\tfor (var key in defaultOptions) {\r\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\r\n\t\t\telse this[key] = defaultOptions[key]\r\n\t\t}\r\n\r\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\r\n\t\t// This allows the developer to easily add properties to segments at construction time.\r\n\t\tif (options != null) {\r\n\t\t\tfor (var key in options) {\r\n\t\t\t\tif (typeof this[key] === 'undefined') {\r\n\t\t\t\t\tthis[key] = options[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// There are 2 additional properties which are set by the code, so need to define them here.\r\n\t\t// They are not in the default options because they are not something that should be set by the user,\r\n\t\t// the values are updated every time the updateSegmentSizes() function is called.\r\n\t\tthis.startAngle = 0\r\n\t\tthis.endAngle = 0\r\n\t}\r\n\r\n\t// ====================================================================================================================\r\n\t// Changes an image for a segment by setting a callback to render the wheel once the image has loaded.\r\n\t// ====================================================================================================================\r\n\tchangeImage(image, imageDirection) {\r\n\t\t// Change image name, blank image data.\r\n\t\tthis.image = image\r\n\t\tthis.imgData = null\r\n\r\n\t\t// Set direction.\r\n\t\tif (imageDirection) {\r\n\t\t\tthis.imageDirection = imageDirection\r\n\t\t}\r\n\r\n\t\t// Set imgData to a new image object, change set callback and change src (just like in wheel constructor).\r\n\t\twinhweelAlreadyDrawn = false\r\n\t\tthis.imgData = new Image()\r\n\t\tthis.imgData.onload = winwheelLoadedImage\r\n\t\tthis.imgData.src = this.image\r\n\t}\r\n}\r\n\r\n// ====================================================================================================================\r\n// Class that is created as property of the wheel. Draws line from center of the wheel out to edge of canvas to\r\n// indicate where the code thinks the pointer location is. Helpful to get alignment correct esp when using images.\r\n// ====================================================================================================================\r\nexport class PointerGuide {\r\n\tconstructor(options) {\r\n\t\tvar defaultOptions = {\r\n\t\t\tdisplay: false,\r\n\t\t\tstrokeStyle: 'red',\r\n\t\t\tlineWidth: 3,\r\n\t\t}\r\n\r\n\t\t// Now loop through the default options and create properties of this class set to the value for\r\n\t\t// the option passed in if a value was, or if not then set the value of the default.\r\n\t\tfor (var key in defaultOptions) {\r\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\r\n\t\t\t\tthis[key] = options[key]\r\n\t\t\t} else {\r\n\t\t\t\tthis[key] = defaultOptions[key]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ====================================================================================================================\r\n// This function takes the percent 0-100 and returns the number of degrees 0-360 this equates to.\r\n// ====================================================================================================================\r\nfunction winwheelPercentToDegrees(percentValue) {\r\n\tvar degrees = 0\r\n\r\n\tif (percentValue > 0 && percentValue <= 100) {\r\n\t\tvar divider = percentValue / 100\r\n\t\tdegrees = 360 * divider\r\n\t}\r\n\r\n\treturn degrees\r\n}\r\n\r\n// ====================================================================================================================\r\n// In order for the wheel to be re-drawn during the spin animation the function greesock calls needs to be outside\r\n// of the class as for some reason it errors if try to call winwheel.draw() directly.\r\n// ====================================================================================================================\r\nfunction winwheelAnimationLoop() {\r\n\tif (winwheelToDrawDuringAnimation) {\r\n\t\t// Check if the clearTheCanvas is specified for this animation, if not or it is not false then clear the canvas.\r\n\t\tif (winwheelToDrawDuringAnimation.animation.clearTheCanvas != false) {\r\n\t\t\twinwheelToDrawDuringAnimation.ctx.clearRect(\r\n\t\t\t\t0,\r\n\t\t\t\t0,\r\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.width,\r\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.height\r\n\t\t\t)\r\n\t\t}\r\n\r\n\t\tvar callbackBefore = winwheelToDrawDuringAnimation.animation.callbackBefore\r\n\t\tvar callbackAfter = winwheelToDrawDuringAnimation.animation.callbackAfter\r\n\r\n\t\t// If there is a callback function which is supposed to be called before the wheel is drawn then do that.\r\n\t\tif (callbackBefore != null) {\r\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\r\n\t\t\tif (typeof callbackBefore === 'function') {\r\n\t\t\t\tcallbackBefore()\r\n\t\t\t} else {\r\n\t\t\t\teval(callbackBefore)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Call code to draw the wheel, pass in false as we never want it to clear the canvas as that would wipe anything drawn in the callbackBefore.\r\n\t\twinwheelToDrawDuringAnimation.draw(false)\r\n\r\n\t\t// If there is a callback function which is supposed to be called after the wheel has been drawn then do that.\r\n\t\tif (callbackAfter != null) {\r\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\r\n\t\t\tif (typeof callbackAfter === 'function') {\r\n\t\t\t\tcallbackAfter()\r\n\t\t\t} else {\r\n\t\t\t\teval(callbackAfter)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If there is a sound callback then call a function which figures out if the sound should be triggered\r\n\t\t// and if so then call the function specified by the developer.\r\n\t\tif (winwheelToDrawDuringAnimation.animation.callbackSound) {\r\n\t\t\twinwheelTriggerSound()\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ====================================================================================================================\r\n// This function figures out if the callbackSound function needs to be called by working out if the segment or pin\r\n// has changed since the last animation loop.\r\n// ====================================================================================================================\r\nfunction winwheelTriggerSound() {\r\n\t// If this property does not exist then add it as a property of the winwheel.\r\n\tif (winwheelToDrawDuringAnimation.hasOwnProperty('_lastSoundTriggerNumber') == false) {\r\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = 0\r\n\t}\r\n\r\n\tvar callbackSound = winwheelToDrawDuringAnimation.animation.callbackSound\r\n\tvar currentTriggerNumber = 0\r\n\r\n\t// Now figure out if the sound callback should be called depending on the sound trigger type.\r\n\tif (winwheelToDrawDuringAnimation.animation.soundTrigger == 'pin') {\r\n\t\t// So for the pin type we need to work out which pin we are between.\r\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getCurrentPinNumber()\r\n\t} else {\r\n\t\t// Check on the change of segment by working out which segment we are in.\r\n\t\t// We can utilise the existing getIndiatedSegmentNumber function.\r\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getIndicatedSegmentNumber()\r\n\t}\r\n\r\n\t// If the current number is not the same as last time then call the sound callback.\r\n\tif (currentTriggerNumber != winwheelToDrawDuringAnimation._lastSoundTriggerNumber) {\r\n\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\r\n\t\tif (typeof callbackSound === 'function') {\r\n\t\t\tcallbackSound()\r\n\t\t} else {\r\n\t\t\teval(callbackSound)\r\n\t\t}\r\n\r\n\t\t// Also update the last sound trigger with the current number.\r\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = currentTriggerNumber\r\n\t}\r\n}\r\n\r\n// ====================================================================================================================\r\n// This function is called-back when the greensock animation has finished.\r\n// ====================================================================================================================\r\nvar winwheelToDrawDuringAnimation = null // This global is set by the winwheel class to the wheel object to be re-drawn.\r\n\r\nfunction winwheelStopAnimation(canCallback) {\r\n\t// When the animation is stopped if canCallback is not false then try to call the callback.\r\n\t// false can be passed in to stop the after happening if the animation has been stopped before it ended normally.\r\n\tif (canCallback != false) {\r\n\t\tvar callback = winwheelToDrawDuringAnimation.animation.callbackFinished\r\n\r\n\t\tif (callback != null) {\r\n\t\t\t// If the callback is a function then call it, otherwise evaluate the property as javascript code.\r\n\t\t\tif (typeof callback === 'function') {\r\n\t\t\t\t// Pass back the indicated segment as 99% of the time you will want to know this to inform the user of their prize.\r\n\t\t\t\tcallback(winwheelToDrawDuringAnimation.getIndicatedSegment())\r\n\t\t\t} else {\r\n\t\t\t\teval(callback)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ====================================================================================================================\r\n// Called after the image has loaded for each segment. Once all the images are loaded it then calls the draw function\r\n// on the wheel to render it. Used in constructor and also when a segment image is changed.\r\n// ====================================================================================================================\r\nvar winhweelAlreadyDrawn = false\r\n\r\nfunction winwheelLoadedImage() {\r\n\t// Prevent multiple drawings of the wheel which ocurrs without this check due to timing of function calls.\r\n\tif (winhweelAlreadyDrawn == false) {\r\n\t\t// Set to 0.\r\n\t\tvar winwheelImageLoadCount = 0\r\n\r\n\t\t// Loop though all the segments of the wheel and check if image data loaded, if so increment counter.\r\n\t\tfor (var i = 1; i <= winwheelToDrawDuringAnimation.numSegments; i++) {\r\n\t\t\t// Check the image data object is not null and also that the image has completed loading by checking\r\n\t\t\t// that a property of it such as the height has some sort of true value.\r\n\t\t\tif (\r\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData != null &&\r\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData.height\r\n\t\t\t) {\r\n\t\t\t\twinwheelImageLoadCount++\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If number of images loaded matches the segments then all the images for the wheel are loaded.\r\n\t\tif (winwheelImageLoadCount == winwheelToDrawDuringAnimation.numSegments) {\r\n\t\t\t// Call draw function to render the wheel.\r\n\t\t\twinhweelAlreadyDrawn = true\r\n\t\t\twinwheelToDrawDuringAnimation.draw()\r\n\t\t}\r\n\t}\r\n}\r\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Wheel.vue?vue&type=style&index=0&id=1cb22e24&scoped=true&lang=css&\""],"sourceRoot":""}